# Facilitating Software Architecture

### 1 - Centralized Architecture Practices in a Decentralized World

- La **software architecture** est :
  - Selon Grady Booch : “the set of significant design decisions that shape the form and function of the system”.
  - Selon Martin Fowler : “those decisions that are both important and hard to change”.
- Pour l’auteur, l’architecture a deux composantes bien mises en valeur par ces deux définitions : (1) le **résultat final du système en lui-même** d’une part, et (2) la **pratique consistant à prendre les décisions d’architecture** d’autre part.
  - Le point (1) a été largement étayé et formalisé sous forme de patterns . Le point (2) beaucoup moins, et c’est l’objet de ce livre.
  - Une bonne architecture implique :
    - Des parties cohérentes, cohésives, et alignées avec le domaine.
    - Des parties découplées permettant à des équipes de travailler en parallèle.
    - Une architecture qu’on peut changer suffisamment facilement.
  - La pratique doit donc permettre d’obtenir ce genre de résultat.
- La pratique de l’architecture sous sa forme **traditionnelle** ne permet pas de répondre aux enjeux d’architecture moderne.
  - Il y a deux formes de pratique traditionnelle (en réalité c’est toujours un mix des deux) :
    - **1 - Ivory tower architects** : les architectes prennent les décisions d’architecture globales, mais aussi locales à chaque produit.
      - On constate en général une homogénéisation de l’architecture pour la rendre plus intelligible et contrôlable par l’architecte, au détriment des spécificités locales de chaque produit.
      - L’architecte est d’autant plus vu comme au-dessus des autres.
    - **2 - Hands on architects** : les architectes vont voir les équipes et co-designent et codent le système avec eux, en passant d'équipe en équipe.
      - Ils n’ont pas le temps de rester assez avec chaque équipe pour répondre à toutes les problématiques, ni le temps de se consacrer suffisamment à la vision globale du système.
  - Le problème principal avec les deux approches, c’est que l’architecte est **responsable des décisions d’architecture à la place des équipes**.
    - Il n’arrive pas à suivre les détails de chaque partie locale que les équipes connaissent mieux, et il manque de temps pour traiter toutes les demandes correctement.
    - Il en résulte qu’il devient un bottleneck pour les équipes, et finit par prendre des décisions de moins bonne qualité.
- Selon l’auteur, le monde du logiciel a connu **5 révolutions** techniques et socio-techniques :
  - **1 - Agile manifesto** : focus sur un code testé qui marche, livré régulièrement, et en faisant confiance aux développeurs pour faire le travail.
  - **2 - Cloud computing** : on a pu déployer des systèmes très rapidement, sans avoir à mettre en place une infrastructure physique pendant des semaines.
  - **3 - DevOps** : on a pu mettre la fonctionnalité dans les main de l’utilisateur en quelques instants, grâce au fait que les équipes de delivery avaient maintenant la main sur le déploiement et la gestion de leur application.
  - **4 - Product thinking** : on a cherché à obtenir du feedback des utilisateurs le plus vite et le plus souvent possible, pour s’assurer de construire la solution qui apporte le plus de valeur.
  - **5 - Stream-aligned teams** : on a privilégié les équipes autonomes responsables des changements de bout en bout, travaillant sur des produits sur lesquels elles ont l’ownership.
    - Cette dernière a eu une période de gestation très longue :
      - Elle était déjà mise en avant dans le livre **_Domain Driven Design_** d’Eric Evans et **_The Principles of Product Development Flow_** de Donald Reinertsen.
      - Elle a été facilitée par le concept de microservices de James Lewis.
      - Puis elle a été popularisée par **_Accelerate_** de la team DORA, **_Inspired_** de Marty Cagan et **_Team Topologies_** de Matthiew Skelton et Samuel Pais.
  - Lorsque ces révolutions sont combinées, on obtient des systèmes très efficaces, capables de mettre chaque incrément de feature dans les mains de l’utilisateur très vite, et de maximiser la valeur.
  - L’approche traditionnelle de l’architecture logicielle est basée sur le contrôle, et ne permet pas d’adhérer aux 5 révolutions : il y a **trop de complexité** dans le système, et **trop de choses qui changent** pour qu’une poignée d’architectes puissent être responsables des décisions d’architecture.
- Les révolutions ont mené à une **décentralisation** de plus en plus grande.
  - Quelques caractéristiques de ce qu’est la décentralisation :
    - La décentralisation n’est **pas la distribution** : il s’agit d’avoir des parties autonomes plutôt qu’un tout séparé en morceaux interdépendants (par exemple monolithe distribué).
    - Décentraliser veut dire **abandonner le contrôle** central et laisser l’indépendance aux parties.
    - La décentralisation **augmente la complexité**. On externalise l’infrastructure, l’envoi de SMS, le paiement et d’autres choses pour pouvoir avoir plus de parties dans notre système.
  - Les **équipes décentralisées** fonctionnent mieux.
    - Les équipes ont parfois des problèmes de couplage avec d’autres équipes : en général soit du _work coupling_ (attendre que l’autre équipe ait fini sa partie), soit du _permission coupling_ (je dois demander avant d’agir).
    - Réduire ces couplages permet d’obtenir de meilleurs résultats mais aussi des développeurs plus heureux (cf. **_Accelerate_**).
    - L’idée est de laisser les équipes travailler en **autonomie**, en réduisant leur cycle de livraison pour qu’ils se préoccupent eux-mêmes de la valeur de ce qu’ils apportent aux clients.
  - Le **logiciel décentralisé** fonctionne mieux. Il n’y a qu’à voir la quantité de briques qu’on externalise chez des providers payants.
  - Pour que ça marche, il faut **aligner les deux**. Très souvent on essaye de décentraliser le logiciel alors qu’on a une structure d’équipe centralisée, et ça fonctionne mal.
    - L’auteur recommande fortement [l'étude célèbre de Conway de 1968](https://www.melconway.com/Home/pdf/committees.pdf) qui ne fait que 4 pages.
- Les pratiques d'architecture et les architectures **centralisées** sont inefficaces.
  - L’idée de centralisation mène souvent à celle de blocage : que ce soit un thread qui en attend un autre, une requête en DB qui attend qu’un row se libère, ou une équipe qui attend de pouvoir déployer .
  - Les pratiques traditionnelles **bloquent le flow de delivery**. Les équipes doivent attendre les décisions des architectes, qui constituent un bottleneck.
    - La raison pour laquelle ce blocage est plus gênant maintenant est que les 5 révolutions du monde du logiciel ont mené à une vitesse de changement bien plus importante qu’avant.
  - Les pratiques traditionnelles **ne permettent pas de récupérer suffisamment de feedback** pour affecter les décisions d’architecture.
    - Les architectes de type “ivory tower” ne récupèrent pas de feedback de leurs décisions et donc finissent par prendre des décisions bonnes sur le papier, mais mauvaises en pratique.
    - Les architectes “hands on” ont moins ce problème, puisqu’ils éprouvent dans une certaine mesure les conséquences de l’implémentation de leur propres décisions d’architecture, mais ils sont alors d’autant plus débordés.
- La **nouvelle pratique** doit permettre de répondre aux 3 buts de l’architecture : cohérente et cohésive, découplée, et adaptable. Pour ça, elle doit :
  - **Être décentralisée** pour permettre aux équipes de travailler en parallèle et de réaliser de nombreuses itérations rapides.
  - **Mettre le feedback au cœur de son fonctionnement**, que ce soit pour les architectes ou les équipes.
- Les pratiques d’architecture **ne peuvent jamais protéger du chaos**, c'est-à-dire des comportements complexes, imprédictibles et sensibles aux moindres changements propres aux architectures.
- L’architecture est fondamentalement **incertaine**, parce qu’incorporant de la **variabilité** à tous les niveaux.
  - Il faut bien prendre l’architecture comme un tout, incluant les systèmes, mais aussi les équipes et leurs interactions, formant un **système sociotechnique**. Cette notion reconnaît la relation entre aspects techniques et aspects sociaux.
  - Il suffit par exemple de prendre ne serait-ce qu’un bout, même simple ou peu important d’un système, et d’en augmenter la latence, pour voir apparaître une complexité qu’on n’imaginait pas.
- L’architecture a des caractéristiques fondamentalement **émergentes**, c’est-à-dire qu’elles sont absentes dans les parties, et apparaissent quand les parties forment un tout.
  - Il existe deux types d’émergence :
    - L’**émergence forte** concerne le fait que des parties forment un tout. Par exemple, les voitures composées de leurs parties.
    - L’**émergence faible** n'apparaît évidente qu’après avoir dû la chercher. On peut la corriger sans difficulté, mais elle apparaîtra quand on pensera avoir pensé à tout.
      - Exemple : L’auteur raconte qu’il avait mis en place un système d’assignation de tracking number dans le cadre d’un outil autour d’ebay. Ces tracking number augmentaient tous les week ends, parce qu’avec du scaling automatique, et l’augmentation de l’activité des utilisateurs le week end, des requêtes étaient en timeout. Le retry provoquait une demande de nouveau tracking number, laissant l’ancien comme réservé mais non terminé. Malgré le fait que l’équipe ait pensé à tout, ils n’avaient pas envisagé la propriété émergente entre leur système de scaling et le comportement des utilisateurs.

## Part I - First Principles

### 2 - To Practice Architecture is to Decide

- Expérience : fermez les yeux et imaginez une décision d’architecture qui est prise.
  - Est-ce que c’était vous ou quelqu’un d’autre qui a pris la décision ?
  - La personne qui a pris la décision était hiérarchiquement au-dessus de vous, en dessous de vous, au même niveau ?
  - Quel âge avait-elle par rapport à vous ?
  - Quelles compétences avait-elle par rapport aux vôtres ?
  - Est-ce que c’était une personne seule ou un groupe ?
- L’architecture est fondamentalement composée de **décisions**.
  - Les architectures évolutionnaires font que ces décisions sont nombreuses et arrivent en permanence. cf. **_Building Evolutionary Architectures_**.
  - Toutes les décisions d’architecture sont des décisions techniques, mais toutes les décisions techniques ne sont pas forcément des décisions d’architecture.
  - Pour définir une **décision d’architecture**, l’auteur met en avant la définition de Michael Nygard dans le blog post [Documenting Architecture Decisions](https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions), qui dit : “_'architecturally significant' decisions: those that affect the structure, non-functional characteristics, dependencies, interfaces, or construction technique_”.
    - **Structure** : si on change la structure, on change la manière dont les parties sont agencées entre-elles. Ces parties peuvent communiquer via le réseau ou via des appels de fonction.
      - Exemples : comment séparer un module en plusieurs parties et quelles équipes vont être responsables de chaque partie
    - **Cross-functional characteristics (CFRs)** : les requirements qui ne rentrent pas dans l’aspect fonctionnel tel que décrit dans une user story ou un use-case, par exemple les sujets de sécurité, de performance, de scalabilité, de réglementation, de coûts etc.
      - L’auteur conseille le chapitre 6 de **_User Story Mapping_** de Jeff Patton, pour une introduction à la notion de user story.
      - Il préfère _cross-functional_ plutôt que _non-functional_ pour éviter de définir par la négation, et aussi parce que ça représente mieux le fait que ces caractéristiques traversent le système.
      - Exemples :
        - Le format des logs et les outils qui vont les collecter.
        - La manière dont on va scaler horizontalement notre système.
      - Mauvais exemples :
        - Le fait de scaler des déploiements à 3 ou 5 pods.
        - Les paramètres à passer au garbage collector de notre virtual machine.
    - **Dependencies** : il s’agit des éléments avec lesquels notre système interagit et qu’on **ne contrôle pas**. On doit donc faire attention à la manière dont on interagit avec ces éléments. Exemple : librairies ou services externes, plateforme qui fait tourner notre code, service fourni par une autre équipe etc.
      - Mauvais exemple : quel framework de unit testing ou outils de performance testing on va utiliser (ça n’impactera pas la manière dont on conçoit le système).
    - **Interfaces** : il s’agit des interfaces qu’on expose aux autres. On en a le contrôle, mais chaque modification à ces interfaces aura des conséquences importantes.
    - **Construction techniques** : les techniques avec lesquelles on construit notre système affectent le système lui-même.
      - Exemples :
        - L’utilisation d’un outil comme LaunchDarkly pour avoir des feature toggles et mettre en prod très vite des features pour certains clients.
        - L’intégration continue nécessite une grenade testabilité.
        - Le TDD nécessite d’isoler la logique métier.
      - Mauvais exemples :
        - Quel IDE les développeurs utilisent.
        - Le fait que les développeurs fassent du pair programming.
- On peut classer les décisions d’architecture en **décisions significatives** et non significatives.
  - Concernant les 3 critères _dependencies_, _interfaces_ et _construction techniques_, les changements significatifs sont en général évidents.
    - Exemple :
      - Une nouvelle dépendance, ou un upgrade majeur pour une dépendance existante.
      - Une nouvelle API qu’on expose, ou un breaking change dans une API exposée existante.
      - Une nouvelle technique de déploiement, comme le canary release, ou le blue-green deployment.
    - Mauvais exemples :
      - Un développeur enlève des dépendances inutilisées.
      - Un architecte enlève un paramètre d’une API dont ils ont vérifié auprès des utilisateurs qu’elle n’était pas du tout utilisée.
      - Un ops déploie une plateforme qui permet aux équipes de partager leurs APIs.
  - Concernant la _structure_ et les _cross-functional characteristics_, c’est plus compliqué de définir s’ils sont significatifs.
    - Concernant les changements de structure, il s’agira soit de changement d’**endroit où on place une logique clé**, soit du fait de **commencer ou arrêter d’utiliser un design pattern**.
      - Exemple : des développeurs qui refactorent leur code pour extraire un micro-frontend (nouveau design pattern).
      - Mauvais exemple : des développeurs refactorent leur code pour extraire une méthode privée dans une classe.
    - Concernant les changements de CFRs, il faut d’abord les **définir clairement** avant de pouvoir savoir si elles sont significatives.
      - 1 - Pour la valeur : “As a [ROLE]…I want to [ACTION]…so that [VALUE].”
      - 2 - Pour le critère d’acceptance : “Given [CIRCUMSTANCES]…when [EVENT]…then [OUTCOME].”
      - Exemple :
        - 1 - As a customer, I want my search results within 500 milliseconds, So that I can find what I want quickly.
        - 2 - Given the site is experiencing normal levels of search requests, When a customer submits a search request, Then the system responds 99% of the time with valid search results within 500 ms.
      - Notre décision sera significative si elle **met en danger le fait de respecter les critères d’acceptation** d’un ou plusieurs autres CFRs.
      - Exemple : un développeur ajoute une API Gateway publique, sans authentification, rate limiting ou autre, juste un pass-through.
      - Mauvais exemple : un développeur refactore du code, enlevant un bottleneck, permettant de doubler le throughput. Aucun critère d’acceptance de CFR n’est en danger, donc ce n’est pas significatif.
  - Des décisions d’architecture peuvent être significatives :
    - Peu importe qu’elles aient été prises **par des architectes ou développeurs**.
    - Peu importe qu’elles aient **pris du temps** ou non.
    - Peu importe qu’elles aient même été **délibérées** ou non.
    - Exemple : une développeur qui met à jour une librairie, et met à jour aussi sans faire exprès des dépendances dont une passe en licence GPL contaminante => c’est un simple développeur, qui a mis peu de temps à décider, et qui ne s’est même pas rendu compte de la décision significative qu’il avait prise.
  - Les décisions ne peuvent être significatives que si elles sont liées à un **système en production**, ou à la partie du système qui permet de mettre le système en production (pipeline CI/CD & co). Tant que la décision n’atteint pas la production, elle ne peut pas être significative.

### 3 - Decisions at Scale

- De manière générale, on peut **décomposer le processus de décision** en plusieurs étapes :
  - 1 - **On a besoin de prendre une décision**.
  - 2 - **On prend la décision**
    - 2.a - **On crée la liste des options possibles**. Cette étape est particulièrement importante.
      - C’est dans cette étape qu’il faut connaître un maximum de patterns d’architecture.
      - C’est aussi à cette étape qu’il faut bien comprendre le problème et le contexte :
        - Quelle est la situation ?
        - Qu’est-ce qui a déjà été essayé ?
        - Quelles sont les contraintes ? Est-ce que certaines sont en tension avec d’autres ?
        - Est-ce que ne rien faire est une possibilité ?
    - 2.b - **On décide**.
    - 2.c - (facultatif) **on communique** sur la décision prise.
      - Cette étape est souvent oubliée, résultant dans le fait que les personnes qui implémentent ne sont **pas au courant, ou pas d’accord** avec la décision.
  - 3 - **La décision est implémentée**.
- L’étape de **création des options possibles** peut être plus ou moins soignée ou bâclée.
  - Il y a 3 manières de la faire :
    - **1 - Le cas nécessitant de l’exploration** : l’étape nécessite de l’effort, on ne peut pas simplement s’appuyer sur des patterns connus et évidents.
    - **2 - La cas où plusieurs options connues existent** : même si les options sont connues, il faut quand même de l’effort pour les expliciter et les mettre en relation les unes avec les autres.
    - **3 - Le cas où on ne considère qu’une option** : parfois parce que la décision n’est pas significative, parfois parce qu’on ne voit pas l’aspect significatif, ou qu’on la prend inconsciemment.
  - Le fait de choisir la manière 1, 2 ou 3 dépend de la décision et de son importance, mais l’auteur remarque que bien souvent on ne consacre pas suffisamment d’importance à la phase de création des options possibles.
  - C’est bien pire pour les équipes de développeurs : bien souvent, ils ne sont pas du tout exposés à cette étape, et ne voient que l’architecte qui prend la décision.
- Les décisions sont difficiles quand elles concernent **un grand nombre de personnes**. C’est là qu’on doit avoir des **processus de décision** solides.
  - Les deux critères importants pour l’auteur sont :
    - 1 - Est-ce que le pouvoir d’initier la décision est centralisé ou décentralisé ?
    - 2 - Quelle est la vitesse à laquelle la procédure permet de définir des options et prendre des décisions ?
  - L’auteur en distingue 6 (elle sont aussi décrites sur [thedecider.app](https://thedecider.app/)) :
    - **Les procédures centralisées** : une seule personne a le pouvoir de décision, et peut l’utiliser de différentes manières.
      - 1 - **Autocratic** decision process : une seule personne crée la liste des options et prend la décision. Les autres ne font qu’implémenter.
        - La prise de décision peut être très rapide, mais la personne peut aussi se retrouver à être un bottleneck si les décisions à prendre s’empilent.
        - Exemple : un chief architect rejoint une entreprise et prend la décision de passer d’AWS à Azure sans avoir consulté personne.
      - 2 - **Delegation** decision process : la personne qui a le pouvoir délègue la décision à une personne, qui va donc lister les options et prendre la décision.
        - Ça ressemble beaucoup à l’_autocratic decision process_, à la différence que la décision peut être plus pertinente si on délègue aux personnes les mieux placées.
        - Exemple : le chief architect rejoint l’entreprise, mais ne connaît pas suffisamment AWS et donc délègue la décision au lead infrastructure architect.
      - 3 - **Consultative** decision process : la personne qui a le pouvoir consulte d’abord les personnes de son choix, avant de faire la liste des options et prendre la décision.
        - Ça peut être un peu plus lent que les deux précédentes méthodes, mais on recueille plus de points de vue. Par contre, vu que la personne choisit de consulter qui elle veut, on peut se retrouver avec des experts du sujet qui ne sont pas du tout consultés.
        - Exemple : le chief architect consulte le lead infrastructure, et quelques autres personnes, avant de lister les options et prendre la décision.
    - **Les décisions décentralisées** : le pouvoir de décision est distribué.
      - 4 - **Consent** decision process : C’est toujours la même personne qui liste les options et prend la décision, mais un groupe large de personnes peuvent bloquer la décision en mettant un véto. S’il y a véto, la personne doit soit faire un autre choix, soit changer la liste des choix possibles.
        - Les personnes non-décisionnaires peuvent parfois abuser du véto, en le mettant jusqu’à ce que la décision soit celle qu’elles veulent. Donc la décision risque d’être lente.
        - Exemple : le chief architect propose de coder les nouveaux microservices en Java 8 parce que c’est ce qu’il connaît. Sa décision est bloquée par un véto d’une ou plusieurs personnes.
      - 5 - **Democratic** decision process : une personne crée la liste des options, mais ensuite le groupe entier vote pour l’option qu’il préfère.
        - La décision va vite, mais le risque c’est que la minorité qui perd se retrouve désengagée parce qu’elle pense qu’elle a de bonnes raisons d’être pour une autre option, même si elle est minoritaire.
        - Exemple : le chief architect propose la liste “Java 8, Cobol, Lisp, Rust”, et le groupe choisit. Il reste quand même la question de savoir qui va avoir un droit de vote : juste les tech leads ? l’ensemble des développeurs ? etc.
      - 6 - **Consensus** decision process : l’ensemble du groupe participe à l’étape de création des options, et aussi à l’étape de la prise de décision, où on s’assure que tout le monde consent avant de décider.
        - On a une bien plus grande implication de chacun, mais la décision risque de prendre beaucoup de temps. Un autre problème peut être le fait d’aller systématiquement vers le choix du plus petit dénominateur commun de compromis : ce n’est pas toujours une bonne chose pour une architecture.
        - Exemple : le chief architect lance le sujet, et les développeurs arrivent à une liste “Kotlin, C#, TypeScript, Rust”, puis discutent jusqu'à arriver à un accord sur un langage.
  - Quand on classe les procédures selon les deux axes (décentralisation et vitesse de prise de décision), on voit qu’on a soit des procédures décentralisées, soit des procédures rapides.
    - On pourrait imaginer le cas “centralisé et lent” avec un autocrate hésitant qui décide seul mais met beaucoup de temps à décider, mais ça n’a aucun intérêt pour nous.
    - L’autre case est par contre beaucoup plus intéressante : est-ce qu’on peut avoir une procédure qui soit **à la fois rapide et décentralisée** ?
      - Si on examine les procédures listées :
        - Sur l’aspect rapidité, **plus la personne qui décide est autonome dans la décision, et plus la décision est rapide**. Consulter les autres prend peu de temps, mais s’ils ont une voix dans la décision elle-même, ça va la ralentir.
        - Sur l’aspect décentralisation, ce qui compte c’est **le nombre de personnes qui peuvent participer** à la décision, mais aussi **le nombre de personnes qui peuvent l’initier**.
      - Et donc, une procédure qui serait à la fois rapide et décentralisée devrait :
        - 1 - Impliquer les bonnes personnes.
        - 2 - Laisser un grand nombre de personnes initier une décision et décider.
        - 3 - Mettre en avant la confiance pour que chacun s’implique dans les décisions où il a quelque chose à apporter.
        - 4 - Minimiser le besoin de communiquer la décision.

### 4 - The Architecture Advice Process

- En tant qu’**architecte traditionnel**, l’auteur a été principalement confronté à 3 problèmes (que ce soit en mode hands on ou ivory tower) :
  - 1 - Étant donné sa responsabilité sur les décisions, il était sur le chemin critique des équipes, et donc finissait par les bloquer d’une manière ou d’une autre.
  - 2 - Il ne pouvait pas être au courant des détails et nuances de l’ensemble des systèmes en place, et finissait par faire des erreurs à cause de ça.
  - 3 - Il n’arrivait pas à communiquer efficacement ses décisions, et donc pouvait ne pas les voir implémentées correctement.
- La notion d’advice process vient initialement du livre **_The Decision Maker_** de Dennis Bakke, puis a été popularisé par **_Reinventing Organizations_** de Frédéric Laloux.
- L**’architecture advice process** peut être décrit comme suit : n’importe qui (membre d’une équipe ou personne avec un rôle cross-team) peut prendre une décision (choisir une des options), à condition d’avoir consulté les personnes suivantes durant la phase de création des options :
  - 1 - Des personnes affectées par la décision
  - 2 - Des personnes qui ont une expertise dans le domaine dans lequel la décision est prise.
- L’_advice process_ peut être vu comme un **contrat social** : on a **confiance** dans le fait que les autres, quand ils prendront des décisions, écouteront les perspectives des bonnes personnes. Et on promet nous-mêmes de faire de même.
  - Cette confiance s’établit entre celui qui décide (une personne, ou une équipe représentée par un membre de l’équipe), et ceux qui subissent la décision, avec dans l’idée que les rôles vont s’inverser régulièrement.
- L’advice process est **à la fois rapide et décentralisé**.
  - Il est **rapide** :
    - Le nombre de personnes qui participent à l’étape de prise de décision est de 1. Le nombre de personnes qui peuvent mettre un véto est de 0.
    - Il se retrouve légèrement plus rapide que le _consultative process_ parce que la décision va être prise par ceux qui en ont le besoin direct, et donc ils seront pressés de la prendre pour avancer.
    - Concernant les personnes consultées :
      - Les équipes vont naturellement chercher à minimiser leur nombre, ce qui va les forcer à construire des systèmes bien délimités.
      - Le rapport aux experts est aussi différent : puisqu’il n’y a plus besoin de les convaincre, on est purement sur du partage de connaissances.
      - Puisque les personnes concernées sont déjà mises au courant du sujet au moment de la consultation, il n’y a plus besoin de faire de grands efforts pour la phase de partage de la décision.
  - Il est **décentralisé**. Si on reprend la définition qu’on se donne de décentralisé : plus il y a de personnes qui peuvent initier et participer aux décisions, plus la procédure est décentralisée.
    - Il offre une **décentralisation maximale sur la question de qui peut prendre une décision** : n’importe qui qui en ressent le besoin.
    - En revanche, il est moins décentralisé que le _consensus process_ parce qu’il n’implique pas tout le monde tout le temps.
      - Il gagne donc sur la rapidité, mais aussi sur la responsabilisation, puisqu’il y a une personne qui porte la décision, là où avec le _consensus process_ la responsabilité diluée entre tous.
- **Story 1** : une équipe de développeurs décide d’utiliser les release toggles.
  - On a une équipe dont le PM pousse à livrer les features par des incréments de plus en plus petits dans les mains du client, et certains membres ayant lu **_Accelerate_**, veulent expérimenter le trunk based development.
    - L’équipe constate qu’il lui faut une manière de cacher les fonctionnalités non terminées : une forme de release toggles.
    - Connaissant bien les tenants et aboutissants de son système, de son contexte, ses compétences etc. l’équipe réfléchit et tombe sur une première solution : **implémenter des checks booléens dans le code** pour cacher les features non terminées.
  - Ils décident alors d’aller demander des conseils, **d’abord aux autres équipes qui pourraient être affectées par cette décision**. Pour les trouver ils se sont posé des questions du genre : quelles équipes devront faire du travail supplémentaire du fait de notre décision ?
    - Le retour principal des équipes concernées est une inquiétude sur leur capacité à tester contre un service qui leur est caché, mais qu’ils auraient besoin de de pouvoir requêter.
    - L’équipe initiale n’a pas pu y penser parce qu’il n’est pas si facile que ça de se mettre à la place des autres pour prendre leur perspective. C’est pour ça qu’on leur demande directement.
  - Ils décident ensuite de demander des conseils aux personnes ayant **une expertise sur le sujet**. Il s’agit de personnes qui ont de l’expérience sur le sujet, ou une vision plus large du système ou dans le temps.
    - Ils vont en parler à Fiona la systems architect, à JB le lead QA, et à Monira, une autre PM dont ils savent qu’elle a eu une expérience avec les release toggles.
    - Fiona un article sur les feature toggles, et leur parle de sa propre expérience, et mentionne notamment le fait qu’il faut que chaque feature toggle soit conçue comme temporaire, avec des mécanismes qui rappelleront de l’enlever pour éviter qu’elle traîne. Elle leur conseille aussi d’en parler avec Yinka, le lead infrastructure pour les histoires d’environnements, de permissions.
    - JB leur parle de la testabilité qui devient un peu plus lourde : par exemple il faut bien penser à tester les features avec le toggle désactivé, et activé.
    - Yinka leur conseille de plutôt passer par des variables d’environnement pour éviter de devoir repasser par la CI et redéployer tout le code juste pour activer/désactiver des toggles.
    - Monira leur dit qu’elle est plutôt d’accord avec les conseils précédents, et ajoute que les variables d’environnement pourraient permettre de faire des démos rapides à un PM ou à un client, sans prendre trop de temps à l’équipe.
  - **L’équipe décide** de suivre le conseil de Yinka pour utiliser les environment variables (qui va aussi arranger les équipes affectées pour leurs tests qui seront plus faciles), et celui de Fiona de tracker les feature toggles, qu’ils choisissent de faire dans Jira pour donner de la visibilité aussi à leur PM (conseil de Monira).
  - Finalement ils reviennent vers les différentes parties prenantes pour leur **annoncer leur décision** : c’est plutôt facile puisque ces personnes ont globalement déjà en tête le contexte.
  - Dans cet exemple, le décision taker et l’option maker est le même : l’équipe qui a ressenti le besoin de ce changement d’architecture.
  - Cette expérience a non seulement permis d’**avoir une solution meilleure** que si l’équipe avait décidé sans advice process, mais aussi a permis à l’équipe :
    - D’en apprendre beaucoup sur le sujet des feature toggles.
    - De mieux comprendre le point de vue des personnes avec des rôles spécifiques (architecte, QA, spécialiste infra etc.).
    - De **tisser un réseau au sein de l’entreprise**, qu’elle renforcera d’autant plus à chaque fois qu’elle aura des décisions à prendre en advice process.
- **Story 2** : un architecte décide de démêler un problème de workflow.
  - La majorité des décisions d’architecture se traitent plutôt comme la Story 1, mais certaines décisions portent sur une problématique qui impacte un **système comprenant plusieurs équipes**. Les personnes les mieux placées pour repérer et traiter ce genre de problématiques sont les personnes qui ont un rôle plus large, comme les architectes.
  - Dans le cadre d’un produit mature, il y a un microservice qui devient petit à petit un bottleneck de delivery et de performance.
    - Initialement, il servait à externaliser la logique de workflow du parcours utilisateur d’une équipe pour pouvoir y faire des changements sans mettre à jour l’app mobile. Puis comme il fonctionnait bien, d’autres équipes y ont ajouté leur logique, et ainsi de suite.
    - Depuis quelque temps, les architectes ont repéré que ce microservice était l’objet de nombreux problèmes. A la fois des bugs difficiles à reproduire, et aussi du **work coupling** : certaines équipes attendent que l’équipe owner du microservice de workflow fasse des modifications pour eux.
  - Un architecte système décide de sonder les **équipes concernées** utilisant le service de workflow pour comprendre ce qu’il fait, et quels sont les besoins de ces équipes.
    - Il remarque que le code est plutôt de bonne qualité, bien testé etc. mais que le microservice fait beaucoup de choses, principalement 3 patterns :
      - 1 - En tant que service de workflow, dirigeant les utilisateurs vers des étapes dont le code était ailleurs.
      - 2 - Le code de certaines étapes devenait dupliqué entre Swift et Kotlin, et donc ces équipes ont décidé de le migrer vers le service de workflow commun, tout en respectant le fait qu’il reste stateless, c’est-à-dire qu’on lui passe l’état et qu’il ne persiste rien. Ils l’ont fait pour éviter la duplication, ce qui est louable.
      - 3 - Certaines équipes avaient construit un système de persistance par dessus le service de workflow pour le rendre indirectement stateful. Ils l’ont fait essentiellement pour des raisons de performance.
  - Il va ensuite parler aux **personnes expertes de ce sujet**.
    - D’abord à Cassie, qui est experte mobile. Elle lui dit que ce genre de problème est régulier dans le monde mobile étant donné la nature des déploiements. Elle conseille :
      - De prendre en compte l’ensemble des besoins des équipes.
      - De les adresser individuellement.
      - De laisser certains problèmes de côté, en demandant aux équipes de simplifier leur implémentation et chercher une solution tierce ou open source de remplacement.
    - Ensuite il parle à Patricia, dev mobile senior récemment embauchée, et venant d’une entreprise qui avait notoirement le même genre de problèmes. Elle raconte les solutions qu’ils avaient mis en place et discute des avantages et inconvénients de certains outils, notamment Kotlin Multiplatform qui permet de mettre en commun du code Android & IOS.
    - Enfin, il parle à des personnes connaissant des systèmes de workflow similaires : Gayathri, un ancien dev qui se souvient de l’enterprise service bus qui existait autrefois, et Isha, un QA qui a travaillé sur un système de workflow à base d’Apache Camel. Les deux donnent des pistes.
  - L’architecte va alors prendre sa décision :
    - 1 - Des refactorings pour encourager les utilisations stateless et rendre plus difficiles les autres utilisations, et le fait d’adopter un fonctionnement _inner source_ pour le microservice, c’est-à-dire comme de l’open source mais en interne.
    - 2 - Identifier un élément de logique partagé entre Android et IOS, et qui s’est retrouvé dans le service de workflow, et le réimplémenter en Kotlin Multiplatform pour le garder côté code mobile plutôt que dans le backend.
    - 3 - Refactorer les utilisations stateful pour les rendre stateless. Chercher des solutions pour régler les problèmes de performance, notamment autour de real time databases for mobile, et backends for frontends.
  - Avant de prendre sa décision, l’architecte invite l’ensemble des équipes concernées et leur présente un draft de la décision, pour prendre des feedbacks, notamment sur la manière d’implémenter les choses.
    - Et finalement l’implémentation se fait petit à petit par les équipes concernées qui ont bien compris l’intérêt du changement.
  - Cette story montre que même pour les décisions avec un large impact, les personnes qui les prennent doivent **au minimum écouter les parties prenantes** et s’appuyer sur elles.
- Pour l’auteur, les notions d’**opinion** et d’**advice** sont des _near ennemies_.
  - _near ennemies_ veut dire que l’un est en quelque sorte la contrefaçon de l’autre. Par exemple :
    - Une équipe DevOps est un _near ennemy_ du mindset DevOps : avoir une équipe distincte est contraire à l’idée fondamentale du DevOps qui est de casser le silo entre Dev et Ops.
    - Une transformation agile imposée par le haut est un _near ennemy_ des équipes agiles : le manifeste parle de laisser les équipes s’auto-organiser en les soutenant, ce qui est le contraire d’imposer une transformation.
    - L’auteur a fait [une présentation d’une liste de near ennemies du DDD](https://www.youtube.com/watch?v=4yr130f-1FE).
  - L’opinion donne une direction mais c’est tout, là où l’advice va donner la direction, mais aussi **expliquer les raisons sous-jacentes de pourquoi** cette direction, et l’**étayer avec des faits, de l’expérience**.
    - Exemple d’advice : _I would use this build because not only does it have licensing terms appropriate to our company’s standards but also because their releases always keep up with the upstream OpenJDK from Oracle, and they have a great wiki as well as an active community who responded rapidly to us when we asked them for help on a weird issue we had_.
    - Exemple d’opinion : _I would use this OpenJDK build because it works better. It’s faster, cheaper, and higher quality._
    - Quand on a une opinion en face de nous, on peut tenter d’en tirer un advice en posant des questions du type “Pourquoi ?”, “Comment ?”.
    - L’architecture consiste souvent en un **it depends on**, et l’advice donne justement la suite du “on”.
  - Certains architectes qui avaient l’habitude de tout décider, risquent dans un premier temps (consciemment ou non) de donner plus souvent des opinions que des advices.
    - C’est une dynamique qui ne devraient pas durer parce que le fait que la personne qui pose la question est celle qui sera accountable, fait qu’à la fois elle a tout intérêt à aller chercher les advices, et à la fois les autres ont tout intérêt à les donner pour que la décision soit la bonne.
- L’advice process se base sur les **conversations**, et notamment que les conversations qui sont nécessaires aient lieu.
  - Le fait de se concentrer sur les conversations dans le cadre de décisions décentralisées fait qu’on se rapproche de la notion d'**anarchie**.
  - Pour que ça fonctionne, il faut que chaque partie se fasse **confiance**. Même si dans les systèmes traditionnels on constate généralement une confiance diminue dès qu’on dépasse le cercle de l’équipe, selon l’auteur, l’advice process permet de maintenir une confiance à plus large échelle.

### 5 - Rolling Out the Architecture Advice Process

- Pour mettre en place l’advice process, la procédure dépend des pouvoirs de prise de décision qu’on a :
  - **Si on a déjà des pouvoirs de prise de décision** (par exemple si on est architecte), on peut directement appliquer l’advice process soi-même. A chaque fois qu’il faut prendre une décision, on interroge les personnes concernées et expertes, **en leur disant bien qu’on le fait dans le cadre d’un advice process**. Ensuite on prend la décision, et on retourne voir les parties prenantes pour la leur communiquer.
  - **Si on manque de pouvoir de prise de décision** (par exemple membre d’une équipe de développement), on peut quand même commencer à appliquer l’advice process, en **indiquant bien à toutes les parties prenantes ce qu’on fait**. La différence c’est qu’on prend **une pseudo-décision**, qu’on donne au vrai décisionnaire à la fin. Le but est de le convaincre que notre équipe est capable de prendre de bonnes décisions de cette manière.
  - **Si on a la capacité à décider de la manière dont on décide** (CTO ou assimilé), on peut mettre en place une **expérimentation à petite échelle** : on prend quelques équipes (pas plus de 3) volontaires et un architecte, et on leur explique l’advice process à expérimenter pendant 3 mois. Une fois que c’est fait, on fait une rétrospective, et on voit ce qu’il faut corriger, et si on peut étendre à plus d’équipes.
- L’auteur identifie **4 problèmes principaux** qu’on rencontre en mettant en place l’advice process :
  - **1 - Une mauvaise compréhension de l’advice process**.
    - Il faut expliquer dès le départ l’advice process aux personnes qui participent à l’expérimentation, par exemple avec une présentation suivie de questions.
    - Il faut insister sur les points principaux, notamment les étapes de la procédure, les rôles des personnes, et le **shift d’accountability**.
  - **2 - Les bonnes personnes ne sont pas consultées pour donner l’advice**
    - Ce problème concerne en général les développeurs qui ne savent pas vraiment à qui parler, plutôt que les architectes qui ont déjà l’habitude d’aller consulter les bonnes personnes.
    - La première chose à faire pour les équipes de développeurs est de demander un advice à l’architecte, notamment pour lui demander ensuite qui d’autre serait pertinent pour donner un advice sur ce sujet.
    - Une bonne pratique est de construire **petit à petit** une liste indiquant les personnes compétentes sur des sujets spécifiques. Par exemple pour “information security”, pour “personally identifiable information”, pour “user onboarding flow” etc.
    - Parfois la liste de personnes à consulter est énorme : c’est pas grave, il faut les consulter quand même. Ça peut pousser à diviser la grande décision en plus petites, ou reconsidérer l’intérêt de prendre une décision sur ce sujet.
  - **3 - On oublie de demander “Pourquoi ?” lors de l’advice et on passe à côté d’informations essentielles**.
    - Attention aux supérieurs hiérarchiques à qui on demande un advice : ils risquent de se cantonner à l’opinion, ou à une direction à suivre. Il faut alors leur demander le pourquoi de leur opinion, et leur rappeler que c’est nous qui sommes accountable.
    - Il faut aussi chercher des advice auprès des personnes avec des points de vues différents du nôtre. Ca ne pourra qu’enrichir notre perspective, et rendre notre décision plus solide.
  - **4 - Un manque de clarté sur le shift d’accountability.**
    - Généralement la crainte qui vient en tête des personnes à qui on parle d’advice process c’est qu’une personne prenne une décision qui ne l’arrange qu’elle, contre tous les advices. Ça révèle que le shift d’accountability n’a pas clairement été compris.
      - Le décideur a l’accountability de la décision (il en subira les conséquences), et donc il a tout intérêt à aller chercher les advices et bien les comprendre pour prendre la meilleure décision possible.
    - On peut imaginer 3 cas où la personne va contre l’ensemble des advices :
      - 1 - Un manque de compréhension du décideur : dans ce cas l’advice process l’aide puisqu’il est poussé à aller chercher les advices.
      - 2 - Un insight unique que seule le décideur a : dans ce cas l’advice process lui permet de le communiquer à ceux à qui il va parler.
      - 3 - De mauvaises intentions : l’auteur n’a jamais vu ce cas, mais si ça arrive il s’agit d’un problème de management, et en dernier ressort la personne n’est peut être pas à sa place dans l’organisation.
    - Dans le cas où une personne n’est pas prête à assumer l’accountability d’une décision, elle peut toujours proposer à quelqu’un d’autre s’il est prêt à porter la décision. La personne initiale pourra peut être apprendre en voyant l’autre faire, et porter une autre décision la prochaine fois.
- Les personnes exposées à l’idée d’advice process ont souvent un **manque de confiance** lié à plusieurs points :
  - Manque de confiance dans sa **capacité à décider**, ou la capacité à décider des autres.
    - C’est normal, les personnes qui n’ont pas l’habitude de prendre des décisions d’architecture vont devoir l’apprendre. C’est une compétence qui s’améliore par la pratique.
    - Un élément qui peut aider est un endroit où chacun recevrait de l’aide pour pratiquer l’advice process, en voyant les autres respecter les étapes, et en le faisant soi-même.
  - Manque de confiance sur **les advices réellement demandés et donnés**.
    - Pour aider à construire sur ce point, on peut mettre en place un mécanisme de **transparence** qui liste les advices donnés et les personnes consultées.
  - Manque de confiance lié au fait de **ne pas savoir tout ce qui se passe**.
    - Il n’y a pas de centre de la décision, et donc on ne peut parler à personne qui ne sache tout ce qui est en cours d’un point de vue architecture.
    - Malgré tout, il serait bon de pouvoir facilement trouver tout ce qu’il faut à propos d’une décision donnée.
  - Ces trois manques de confiance peuvent être **mitigés par la mise en place des ADRs**.

### 6 - Architectural Decision Records

- L’auteur considère l’ADR comme outil minimal pour accompagner l’introduction de l’architecture advice process.
- L’ADR va cadrer **l’ensemble des 3 étapes du processus de décision** : _option making_, _decision taking_ et _decision sharing_.
- Historiquement, l’ADR :
  - Date de 2005 dans un papier de Jeff Tyree.
  - A été popularisé par [un blog post](https://oreil.ly/YKQ7r) de Michael Nygard.
  - Est détaillé [sur un site de référence](https://adr.github.io).
  - A un chapitre consacré dans **_Fundamentals of Software Architecture_**.
- Les ADRs ont en général un contenu texte d’environ **2 pages**, et sont **immutables**, c’est-à-dire que si on veut changer une décision, il faut refaire un ADR.
  - Ils sont écrits **de manière à en faciliter la lecture, au détriment de l’écriture**.
- Un ADR complet est **structuré de cette manière** :
  - **Le titre** doit être suffisamment descriptif pour comprendre la décision sans ouvrir l’ADR. Il doit donc être changé une fois la décision prise pour **inclure la décision**.
    - Exemple : _ADR002—Shorten Inventory IDs with Nano ID_
  - **Les metadata** :
    - **L’identifiant** permet de se référer à l’ADR sans aucune ambiguïté.
    - **Le statut** permet de savoir où en est l’ADR.
    - **La date** permet de savoir quand est-ce que le statut a évolué pour la dernière fois (sachant qu’une fois _Accepted_, il ne peut plus changer).
    - L’auteur est la personne (ou l’équipe si une équipe entière s’en charge) qui est responsable de prendre la décision.
  - **La décision** indique l’option choisie, et la décrit brièvement. Elle n’indique pas le contexte, les avantages et inconvénients ou les autres options possibles.
  - **Le contexte** permet de savoir pourquoi la décision est importante, et les aspects principaux qu’avait l’auteur en tête au moment de l’ADR.
    - Il est en dessous de la décision parce que pour le lecteur la décision est plus importante à connaître immédiatement.
  - **Les options** représentent les possibilités considérées.
    - On met **en premier celle qui est sélectionnée** par le décideur pour faciliter la vie des lecteurs.
    - Les options **sont juste listées** pour pouvoir les avoir sous les yeux toutes en même temps, les conséquences sont détaillées en dessous. On peut aussi faire la version où les conséquences sont détaillées pour chaque option, mais l’auteur préfère les séparer pour aider le lecteur de l’ADR.
    - Exemple :
      - 1. (SELECTED) A4VHAOFG: Random generated letters and numbers with Nano ID
      - 2. 123456: Automatically generated sequence ID
      - 3. Canvas: Manually generated ID
  - **Les conséquences** indiquent pourquoi chaque option a été choisie ou rejetée.
    - Pour l’option sélectionnée, on va laisser les avantages “Selected because…” et les inconvénients “Selected despite…”.
    - Pour les autres options, on peut se restreindre aux désavantages pour lesquels on ne les a pas sélectionnés. Parfois, on peut vouloir mettre aussi les avantages.
  - **Les advices** contiennent chaque advice récolté par le décideur, **avec le nom** de la personne qui a donné l’advice, et **la date** de l’advice.
    - Cette section est un ajout à la structure habituelle des ADRs, pour qu’ils servent de socle à l’advice process.
- L’ADR sert aussi de **support pour aider dans le processus de décision** :
  - **Étape 1 : on crée l’ADR vide, et on remplit les metadata.**
    - [Un template fait par l’auteur est dispo ici](https://github.com/andrewharmellaw/facilitating-software-architecture/blob/main/adr/adr-template.md).
    - Le titre n’a pas beaucoup d’importance à ce stade, il sera de toute façon changé très bientôt.
  - **Étape 2 : on remplit le contexte.**
    - On cherche les choses à mettre **après le “on” de “it depends on”**. Le but est de comprendre l’espace du problème.
    - Pour l’auteur, les sections _Contexte_ et _Consequences_ sont les deux plus importantes pour aider à la prise de décision.
    - On écrit ce qui nous passe par la tête, puis on met en forme en ayant en tête les potentiels advisers comme cible.
      - D’ailleurs si des advisers nous viennent en tête, il faut noter leur noms pour ne pas oublier de leur parler.
    - On peut aussi ajouter un schéma pour expliciter le contexte, sans passer trop de temps dessus à ce stade.
  - **Étape 3 : on liste les options et leurs conséquences.**
    - On commence par la partie conséquences : on écrit les conséquences pour les options qu’on a déjà en tête, sans oublier d’envisager l’option “ne rien faire”. Le but est de d’éclairer les raisons d’envisager chacune des options dans notre contexte.
    - Idéalement il faudrait se retrouver avec 3 à 5 options, 2 étant un minimum.
    - On continue à raffiner les conséquences de nos options tout au long du processus de décision. On peut aussi ajouter des schémas pour les représenter plus clairement.
  - **Étape 4 (optionnel) : pré-sélectionner une option**
    - Si on pense qu’une des options est préférable à ce stade, on peut la pré-sélectionner, et changer le statut de l’ADR de “Draft” à “Proposed”.
    - Cette étape est **optionnelle.**
      - Pré-sélectionner une option avant d’aller demander des advices a l’avantage de leur **indiquer dans quelle direction on s'apprête à aller**, pour qu’ils concentrent plus d’attention à éventuellement critiquer cette option.
      - Mais ça peut aussi avoir **l’inconvénient de les influencer, en particulier si on a une position d’autorité**.
  - La suite est d’aller voir les personnes qui vont donner des advices.
- **Étape 5 : on va chercher les advices, et on met à jour l’ADR.**
  - Conseils généraux :
    - On peut solliciter des advices **tôt dans le processus de décision**, dès qu’on a un début de draft de la section _Contexte_. Dans ce cas, on demande de l’aide pour construire le contexte et les options.
      - C’est ce qu’avait fait l’architecte dans la Story 2 : il était allé voir les équipes concernées pour voir l’usage de chacune du module de workflow.
    - On peut solliciter des advices **tardivement**, une fois qu’on a affiné nos options et conséquences, et qu’on en a pré-sélectionné une.
      - C’est ce qu’avait fait l’équipe dans la Story 1 : ils avaient pré-sélectionné l’option des toggles dans le code, avant d’aller voir les autres équipes qui leur ont dit qu’en fait ça avait un impact sur eux.
    - Les advices doivent porter sur **l’ensemble des parties de la décision**.
      - Il faut bien le **préciser explicitement aux personnes à qui on demande des advices**, en particulier si on leur demande tardivement sur un ADR déjà bien rempli.
      - Les advices peuvent :
        - Ajouter des options.
        - Améliorer la section _Context._
        - Donner des insights supplémentaires sur les conséquences positives et négatives des options.
        - Amener à scinder la décision en plusieurs décisions.
    - Si nécessaire, on peut retourner voir une personne qui nous a déjà donné un advice pour creuser quelque chose qu’on n’avait pas en tête à ce moment-là.
  - Avant d’aller chercher les advices, on **établit une liste de personnes** qu’on pense être celles impactées par la décision, et celles qui sont expertes du domaine. On met cette liste dans la section _Advices_ de l’ADR.
  - On peut ensuite **mettre en place des meetings** avec chaque personne.
    - Avant le meeting, on lui met à disposition l’ADR tel qu’il est actuellement, pour que la conversation puisse être plus efficace.
    - Pendant le meeting, on prend des notes sur les advices que la personne donne, dans la section _Advices_ de l’ADR.
    - Après le meeting, on met en forme les notes, et on demande à la personne de les relire après coup, pour être sûr qu’il s’agit bien de **son advice clair et complet**, et d’ajouter ce qu’il faut sinon.
  - A chaque fois qu’on a fait un meeting avec une personne, on repasse sur l’ADR pour mettre le **mettre à jour si nécessaire** au regard des advices données.
    - On ajoute les éléments supplémentaires, comme par exemple des options nouvelles, **même si on est en désaccord avec celles-ci**, ou des avantages ou inconvénients supplémentaires pour certaines options.
    - On peut clarifier certaines parties si elles avaient été mal comprises par la personne donnant l’advice.
    - On peut indiquer dans le texte de l’ADR quand il y a des advices qui vont à l’encontre de notre avis et qu’on choisit de ne pas suivre.
      - TODO : technique montrée plus tard ?
- **Étape 6 : on prend la décision, et on complète l’ADR.**
  - On met à jour les options et les conséquences en fonction de l’option choisie :
    - On rédige la section _Options_ qui liste les options, avec l’option sélectionnée en 1er.
    - On déplace les conséquences de l’option sélectionnée en haut de la section _Consequences_, en l’indiquant comme sélectionnée.
    - On reformule les upsides et downsides pour l’option sélectionnée en “Selected because…” et “Selected despite…”, et pareil pour les options non sélectionnées “Rejected because…” et “Rejected despite…”.
  - On remplit la section _Decision_, et on change le titre pour refléter l’option choisie.
  - On change le statut à “Accepted” et on met à jour la date.
- **Étape 7 : on partage la décision**, en partageant l’ADR avec tous ceux qui sont concernés ou qui ont contribué.
- Concernant les statuts des ADRs :
  - Il y a les statuts classiques : _Draft_, _Proposed_, _Accepted_, _Superseded_.
    - Superseded est utile quand une décision est en partie invalidée par une décision ultérieure.
  - On peut aussi ajouter des statuts non standards qui peuvent parfois être utiles :
    - _Expired_ : pour faire un ADR explicitement timeboxé, et qu’il faut revisiter à un certain moment parce qu’il expire.
    - _Retired_ : dans le cas où un produit est retiré de la circulation, l’ADR le concernant peut être considéré comme retiré de la circulation aussi.
    - _Rejected_ : pour l’auteur n’est pas utile. Soit c’est _Accepted_ avec la décision de ne rien faire, soit Superseded par un autre ADR si on change la décision.
- Les ADRs doivent être dans **un même endroit** (d’où l’intérêt d’un ID unique).
  - Il vaut mieux éviter les outils spécifiques aux architectes pour faire en sorte que l’ensemble des développeurs l’utilisent aussi.
  - Une des solutions est le wiki (ou assimilé) qui contient déjà la documentation des produits existants.
  - Une autre possibilité est d’utiliser le gestionnaire de version, créer une pull request par ADR (qu’on merge quand le statut est _Accepted_), et rédiger l’ADR dans un fichier markdown.
  - Enfin, la solution préférée de l’auteur est d’utiliser un outil de ticketing. Ça a l’avantage de pouvoir mettre en avant certains champs (Auteur, Statut, Date), être alerté par exemple quand le statut d’un ADR change, ou encore pouvoir afficher les ADRs selon des critères particuliers (recherche par auteur, par date etc.).
- Les ADRs doivent **raconter l'histoire du système**. Il faut donc qu’une personne avec un rôle cross-équipe s’occupe de :
  - S’assurer régulièrement que les ADRs ont un identifiant unique et un titre clair.
  - Créer et maintenir **une page de changelog qui montre les ADRs acceptés** en partant du plus récent.
  - Créer et maintenir **une page donnant un résumé ou une liste des ADRs les plus importants**.
    - La page peut être enrichie avec des diagrammes, des liens vers des endroits importants de la codebase, ou une _domain-driven design vision_ (cf. chapitre 15 de **_Domain-Driven Design_** d’Eric Evans).
    - Les ADRs les plus importants sont notamment ceux qui ont l’impact le plus large, mais également par exemple des ADRs avec un impact large et où il a été choisi de ne rien faire.

## Part II - Nurturing and Evolving Your Culture of Decentralized Trust

### 7 - Replacing Hierarchy with Decentralized Trust

- Dans les entreprises traditionnelles, les personnes qui décident de l’architecture gardent l’accountability au sujet des conséquences, même quand elles délèguent la prise de décision à quelqu’un d’autre.
  - Il y a un vrai shift dans l’architecture advice process : la personne qui prend l’initiative et porte une décision est accountable elle-même des conséquences de sa décision.
- Les frameworks “enterprise” d’architecture comme The Open Group Architecture Framework (TOGAF) ou Open Agile Architecture (O-AA) sont compatibles avec l’advice process, notamment parce qu’ils ont dû s'adapter aux 5 révolutions, et acceptent le shift de responsabilité et d’accountability.
- L’accountability revient au décideur : soit l’architecte pour les décisions cross-équipes, soit l’équipe entière (ou le team lead si l’équipe choisit de faire comme ça) pour les décisions où une équipe est principalement concernée.
- Personne n’est obligé de décider, mais ceux qui le font doivent utiliser l’advice process en toute transparence, et ceux qui veulent se lancer sont encouragés.
- Pour que l’advice process marche et que la confiance s’installe et perdure, il faut trouver **juste assez d'accords formels** (contrat social, ADR), et **juste assez de pratiques standard** (tout ce qui vient dans les quelques chapitres suivants).
- La mise en place de l’advice process **laisse de la place** pour de la confiance et de l’apprentissage, l’ancienne culture d’entreprise va avoir tendance à venir s’engouffrer dans cet espace, et **potentiellement menacer la confiance**.
  - L’auteur propose la définition de Jeffrey Liker pour la culture : “the pattern of basic assumptions… a given group has… to cope with the problems”.
  - Selon qu’on soit dans un climat avec une confiance importante ou faible, on aura **plus ou moins besoin des outils supplémentaires** décrits dans les chapitres suivants. On ne peut pas juste espérer que la confiance va arriver d’elle-même.
    - La question à se poser : Which supporting elements are required to nurture and sustain trust among everyone in your organization without getting in the way of flow?
  - Deux exemples de culture avec et sans confiance :
    - Avec de la confiance : on a une organisation où toutes les équipes adoptent organiquement la même stack, facilitant le recrutement et les mouvements à l’intérieur de l’organisation. Les développeurs partent du principe que leurs collègues sont compétents.
    - Sans confiance : on a une organisation où toutes les équipes mettent place de l’over-engineering pour supporter un scale et une reliability non nécessaires, et ont peur de prendre des décisions communes avec les autres, parce qu’elles partent du principe que l’architecture mise en place par les autres ne sera pas à la hauteur.
  - Dans une organisation avec une **faible confiance**, on peut être amené à **cacher des informations ou bloquer des décisions pour exercer un contrôle**.
  - La confiance doit être cultivée : en fonction de la **taille de l’entreprise**, il faut **doser les process** pour l’alimenter sans trop limiter le flow.
    - Les petites startups qui ont une culture de l’ownership collectif peuvent s’en sortir au début avec très peu de process. Ça marche parce que chacun se fait confiance. Tout le monde est autour de la table quand les décisions sont prises, quel que soit le mode de décision du moment, et tout le monde est aligné sur l’objectif.
    - Une fois que le groupe grossit un peu trop (en gros, au delà de deux équipes agiles), **un split subtile et graduel** commence à se former : le groupe dominant qui a plus de pouvoir (contrôle de l’information et de l’accès aux ressources, sur le fait de fixer l’ordre du jour etc.), et qui en général ne s’en rend pas compte, et un ou plusieurs groupes périphériques qui le vivent assez douloureusement.
      - Il s’agit d’un phénomène universel des groupes humains, décrit par exemple par Jo Freeman en 1972 dans [The Tyranny of Structurelessness](https://www.jofreeman.com/joreen/tyranny.htm).
    - Pour éviter que la confiance s’érode trop, il faut des éléments structurants plus formels : un **processus de décision** (dans notre cas l’advice process), et des mécanismes pour assurer la **transparence** et l’**alignement** (les ADRs comme un minimum, et les 5 autres éléments au besoin).
- En dehors des deux éléments **formels et structurants** que sont l’advice process et les ADRs, il faut bien savoir doser ce qu’on met en place **en fonction de son contexte**, pour que la confiance puisse prospérer.
  - La nature et le nombre de ces éléments peut varier au cours du temps, en même temps que le contexte général du département tech et de l’entreprise. L’organisation doit donc apprendre et s’adapter en permanence.
  - Il y a un risque non nul qu’on **tende inconsciemment à ajouter de la structuration** pour revenir à l’ancienne manière hiérarchique et bureaucratique. Il faut donc se demander à chaque fois si ça **correspond à un vrai besoin**.
    - Exemple : l’auteur propose à une CTO cliente de mettre en place un meeting hebdomadaire pour aider à donner des advices. Elle lui fait remarquer que ça allait à l’encontre de leur culture remote et asynchrone. Finalement ils se sont interrogés sur le besoin réel, et se sont concentrés dessus. Ils ont fini par mettre en place un meeting de 30 minutes, avec une préparation avant ou après le meeting.
    - L’exemple de Netflix permet de voir les choses du point de vue de la réduction de structuration : ils ont décidé d’enlever de la structure, jusqu’à obtenir le minimum nécessaire pour que ça fonctionne. Le résultat a été la responsabilisation de chacun.
    - Il faut à chaque fois se demander si l’ajout d’un élément de structuration ne répond pas juste à un besoin de rendre les choses plus prédictibles. Cette pente est glissante.
  - La solution est d’expérimenter les éléments régulièrement, un à la fois, et de voir s’ils améliorent le flow et la confiance dans l’organisation, ou non.

### 8 - An Architecture Advice Forum

- L’architecture Advice Forum est un meeting régulier qui permet à la fois de **donner de l’espace pour l’advice process** qu’on utilise déjà par ailleurs, et de le **mettre en scène aux yeux de tous**.
  - Il **augmente la confiance** en rendant transparent en live une partie de l’application du process.
- Il ne s’agit pas de donner un nouveau nom aux meetings traditionnels d’architecture (Architecture Decision Forums ou Architecture Review Boards).
  - Il n’y a **pas de prise de décision ou de validation** dans le meeting. L’advice process s’applique et les décisions reviennent à ceux qui les portent.
  - On y trouve :
    - **1 - Au moins un représentant par équipe** jouant le rôle de partie affectée par les décisions.
    - **2 - Les personnes avec de la connaissance domaine spécifique** jouant le rôle d’experts à qui on demande souvent des advices. Par exemple des spécialistes UX, QA, InfoSec etc.
    - **L’event est ouvert à qui veut** dans l’organisation.
  - Il met en scène des conversations qui ont généralement lieu en 1&1.
    - Il permet à tous ceux qui regardent d’**apprendre comment donner et demander des advices**, mais aussi d’en apprendre plus sur les thématiques spécifiques liées à l’architecture. C’est donc typiquement un meeting dont on tire bénéfice, même sans intervenir.
    - Il **encourage les désaccords sans avoir le côté “chercher à l’emporter”** parce qu’il n’y a aucun enjeu de prise de décision dans le meeting.
- Les advices peuvent être donnés pendant ce meeting, mais aussi en dehors. **Le meeting ne remplace pas l’advice process en 1&1**, il vient lui donner un espace supplémentaire particulier, où le process a lieu sous les yeux de tous.
- **Déroulé d’un Architecture Advice Forum :**
  - **1 - On établit un agenda** pour le meeting, et on met ça dans une page de wiki. Chaque session a 3 catégories de sujets :
    - Les ADRs qui ont besoin d’advices.
    - Un suivi des ADRs des sessions précédentes dont le statut n’a pas bougé.
    - “Any other business” : attention à ce que les sujets qui arrivent ici soient bien dans la thématique de l’advice process, il ne s’agit pas de dévier le meeting vers autre chose.
  - **2 - On partage l’agenda**. On fait appel à ceux qui veulent mettre leur ADR pour recevoir des advices, ou d’autres sujets. Des sujets seront probablement ajoutés y compris au dernier moment quand le meeting commence.
  - **3 - Démarrer la session**.
    - On commence par passer en revue qui n’a pas pu être là. C’est important pour ne pas donner l’impression que présenter son ADR au forum est suffisant : il faut quand même aller chercher les advices de ceux concernés ou experts même s’ils n’ont pas pu être là.
    - Ensuite on aborde la partie 1 avec ADRs qui ont besoin d’advices.
  - **4 - La personne introduit son ADR**.
    - Elle présente les aspects les plus importants : le contexte, ce qui en fait une décision significative, ce qu’il a découvert d’intéressant, et ce sur quoi il aimerait des advices.
  - **5 - Les personnes qui le veulent donnent des advices**.
    - C’est à la fois à la personne qui porte l’ADR de s’assurer qu’elle obtient bien des advices des personnes présentes qui seraient affectées par la décision ou expertes sur le sujet, et à la fois aux personnes en question d’intervenir pour donner l’advice.
    - Le meeting n'exonère pas d’**enregistrer l’advice dans l’ADR** dans la section _Advices_. La personne qui porte l’ADR doit donc prendre des notes pour le faire plus tard.
    - **Tous les advices donnés doivent tous être enregistrés**, que le porteur de l’ADR soit en accord avec l’advice ou non, et qu’il veuille l’incorporer au sein de l’ADR (en dehors de la section _Advices_) ou non.
- L’_architecture advice forum_ peut favoriser des conversations d’égal à égal, où on se concentre sur les arguments en en faisant profiter un auditoire. Mais il peut aussi devenir **le lieu de confrontation et de lutte de pouvoir**.
  - Les développeurs sont habitués à aborder l’architecture sur un mode de confrontation : deux parties s’opposent frontalement, jusqu’à ce qu’une autorité hiérarchique vienne les départager en prenant la décision. Ils vont probablement le reproduire pendant l’architecture advice forum puisque c’est ce qu’ils connaissent par défaut.
    - Exemple : l’auteur raconte qu’un architecte concluait chaque discussion d’ADR avec “So, do we all agree?”, même si l’auteur lui avait dit de nombreuses fois que c’était une mauvaise approche.
  - Il existe une approche de la discussion qui n’est pas confrontationnelle : la **coalescent argumentation**.
    - C’est tiré du livre **_Coalescent Argumentation_** de Michael Gilbert.
    - La méthode consiste à se concentrer sur la recherche du but commun plutôt que sur la recherche d’informations pour mettre l’autre en défaut.
      - **On se demande d’abord : avec quoi je suis d’accord ?** pour faire émerger ensuite les éléments de désaccord comme des chemins qui divergent de la base commune en se demandant : **avec quoi je _dois_ être en désaccord ?**
      - Dans la manière confrontationnelle on va plutôt se demander : **avec quoi je _pourrais_ être en désaccord ?** Et tâcher ensuite de combattre ces idées.
    - Les ADRs avec advice process sont par nature faits pour permettre un mode coalescent :
      - L’auteur de l’ADR place d’abord son point de vue dans la section _Context_ et éventuellement _Consequences_.
        - Par exemple dans la _Story 1_, l’équipe de développeurs avait envisagé une solution centrée autour du code, puisqu’ils avaient le contrôle sur ça.
      - La section _Advice_ permet ensuite de valider ce qui se trouve dans la vision partagée et qui rejoindra la section _Context_, et ce qui diverge et donnera potentiellement des options alternatives dans la section Consequences.
        - Dans la _Story 1_, chaque partie concernée apporte sa pierre pour affiner la compréhension du problème. Certains n’hésitent pas à donner un feedback honnête, comme le QA qui dit que ça lui fera plus de travail.
    - La _[coalescent argumentation](http://www.extremeprogramming.org/stories/pair.html)_ peut se rapprocher de ce qui est fait en pair programming, notamment avec les [XP Pair Programming idioms](http://www.extremeprogramming.org/stories/pair.html).
- L’architecture advice forum permet des avantages pour l’ensemble des participants.
  - Les _advice offerers_ peuvent entendre les advices des autres _advice offerers_ et rebondir dessus pour clarifier ou ajouter des choses. Ça apporte de la rapidité et de la transparence. Il faut par contre que la psychological safety soit élevée.
  - Les _advice seekers_ peuvent vraiment se concentrer sur les advices tout en gardant le pouvoir de décision. Ils auront plus de mal à ignorer un point appuyé en public par plusieurs personnes, mais il y a un risque que certaines personnes influentes en jouent pour forcer la décision. La solution est pour les _advice seekers_ de se concentrer sur le raisonnement qui sous tend l’advice.
  - Les observateurs peuvent assister à des échanges constructifs où les arguments de fond ne sont pas masqués par des jeux de pouvoir du fait de l’absence d’enjeu du meeting. Ils peuvent apprendre sur l’architecture, et aussi voir le processus de décision à l'œuvre et finir par se sentir prêts à ouvrir un ADR eux-mêmes.
- L’architecture advice forum permet aussi de **rassembler des équipes** qui généralement travaillent indépendamment pour obtenir une **cohésion sociale**, et de **rassembler des systèmes** qui évoluent indépendamment pour obtenir une **intégrité conceptuelle**.
  - L’auteur se base notamment sur les principes expliqués dans The**_ principles of Product Development Flow_** de Donald Reinertsen, qui décrit une approche lean du product development.
  - L’advice forum permet de faire émerger une vision partagée de l’architecture, et donc aussi **les points où il y a un décalage de vision architecturale**.
    - Par exemple, le problème décrit dans la story 2 aurait sans doute pu être détecté plus tôt si les décisions d’architectures étaient régulièrement discutées en groupe.
    - Vu que les parties prenantes sont rassemblées, quand le besoin d’une équipe éphémère pour résoudre un problème important se fait sentir, ils peuvent naturellement la mettre en place, en y mettant les bonnes personnes. C’est beaucoup plus efficace et motivant qu’une décision venant de la hiérarchie.
  - Pour les personnes disposant d’une expertise très spécialisée (sécurité, légal etc.), c’est l’endroit idéal pour apporter leur angle à chacune des décisions prises.
  - Ca permet d’améliorer la cohésion sociale grâce à la **transparence**.
    - Les petites influences proposées par chacun permettent au système de ne pas dévier dans la mauvaise direction petit à petit.
    - Tout le monde peut obtenir une idée de la manière dont les décisions se forment puis donnent lieu à une coordination, et agir en conséquence en ayant les enjeux importants du moment en tête.
    - En voyant les décisions prises, l’ensemble des participants a confiance dans les capacités de chacun à prendre des décisions.
  - Un autre élément qui permet de profondément soutenir la cohésion sociale est la forme **régulière et collective** des meetings d’architecture advice forum, qui sont comme des rituels.
    - Ils permettent de **réduire l’anxiété** issue de la nature non prédictible des systèmes que nous construisons.
    - Ils regroupent des personnes séparées par la nature de leur rôle, et les placent **côte à côte en tant que pairs**, pour affronter l’incertitude collectivement.
- **Comment le mettre en place ?**
  - Le **Terms of Reference** : on peut écrire un document d’une page pour décrire en quoi consiste le meeting et comment il se déroule.
    - L’auteur en a mis [un exemple sur github](https://github.com/andrewharmellaw/facilitating-software-architecture/blob/main/adviceforum/terms-of-reference.md).
  - Dans le cas où on met en place l’architecture advice process en même temps que l’advice process lui-même, il faut bien penser à **commencer avec un petit groupe**. L’idée est d’expérimenter, établir de la confiance entre les participants, pour pouvoir le grossir et garder l’esprit d’advice process.
  - Qui inviter au départ ?
    - Idéalement déjà le lecteur du livre.
    - Et ensuite les personnes que le lecteur peut affecter : si on est dans une équipe on invite l’équipe, si on est architecte on invite les équipes avec lesquelles on travaille etc.
    - Les autres personnes éventuellement invitées ne peuvent être que des _advice offerers_.
  - Le 1er advice forum nécessitera un peu plus de **préparation** :
    - Créer un template d’ADR qui va bien.
    - Créer un endroit pour mettre les ADRs.
    - On doit préparer une explication du process pour ceux qui participeront, y compris en quoi ça déplace l’accountability etc.
      - Il nous faut aussi timeboxer l’expérience et mettre décider de la manière de mesurer son succès.

### 9 - Testable CFRs and Technology Strategy

- Les ADR et l’advice process permettent d’obtenir une intégrité conceptuelle de l’architecture, et une cohésion sociale des équipes, et donc ils permettent un **alignement technique**. Mais ils ne sont pas suffisants pour garantir l’**alignement organisationnel**.
  - La question à se poser pour savoir si on est aligné au niveau de l’organisation entière c’est : est-ce que nos systèmes permettent de **délivrer de l’impact pour l’organisation** ?
  - En réalité, le fait que la technique soit alignée avec l’organisation est encore plus important que le fait que les équipes techniques soient alignées entre-elles.
  - C’est en s’alignant sur les objectifs de l’organisation qu’on peut répondre aux questions comme :
    - Est-ce que cette prise de risque est raisonnable ?
    - Est-ce que le coût de cette infrastructure est raisonnable ?
    - etc.
  - Le **manque d’alignement organisationnel** peut être détecté par des signaux :
    - 1 - Quand des décisions amènent à de la duplication d’effort sans qu’il n’y ait d’intérêt. Par exemple, si tous les services sont chez un cloud provider, et qu'une équipe décide de déployer un service chez un autre cloud provider sans que ça n’apporte d’avantage différenciant.
    - 2 - Quand des débats sur des points fondamentaux reviennent sans cesse, par exemple sur l’intérêt d’utiliser le CQRS sur les nouveaux microservices.
    - 3 - Quand les décisions d’ADR portent en majorité sur de la pure technique. Par exemple les langages, les détails d’infra etc. sans prendre en compte les besoins fonctionnels.
  - L’Open Group Agile Architecture décrit l’alignement organisationnel des équipes autonomes en **4 mécanismes** : les équipes alignées doivent avoir une conscience partagée, des feedback loops, un cadre (forcing functions), et un but partagé.
    - La **conscience partagée** et les **feedback loops**. sont adressés par l’**advice process**.
    - Le **but partagé** est adressé par la **stratégie technologique actionnable**.
    - Le **cadre** est accompli par :
      - Les **engagements** qui sont adressés par les **principes architecturaux partagés**.
      - Les **guidelines** qui sont adressés par le **technology radar**.
      - Les **restrictions et requirements** qui sont adressés par les **CFRs testables**.
  - Une des manières de voir qu’on manque d’alignement organisationnel est le **principe de la moindre surprise** : si nos collègues agissent d’une manière à nous amener à être surpris, c’est peut être qu’on manque d’alignement.
    - C’est particulièrement facile à voir sur les CFRs parce qu’il sont très spécifiques. Par exemple si on a le CFR de max 500ms pour le chargement d’une page pour l’utilisateur, alors on s’attend à ce que tout le monde l’ait en tête, et au moins que personne n’ait en tête un autre chiffre, ou le fait qu’il n’y a pas vraiment de limite. Sinon on va être surpris.
    - Autre exemple sur la stratégie technique : toutes les équipes peuvent choisir leur langage mais déploient sur AWS, avec une équipe plateform qui met en commun l’outillage nécessaire pour ça. Une nouvelle équipe arrive pour créer une data platform et la déploie sur GCP. C’est peut être une décision stratégique pertinente liée à une spécificité de GCP et du fait que ce produit est clé, mais si on ne met pas à jour la stratégie technique pour le dire, on va petit à petit avoir d’autres équipes qui vont commencer à utiliser GCP à leur tour.
    - Toutes les organisations n’ont pas besoin des mêmes choses sur lesquelles il y a des accords, elles ont chacune besoin d’**établir des accords sur les sujets qu’elles estiment importants pour elles**. Ces accords peuvent être écrits ou non, mais ils doivent être dans la tête de tout le monde, pour que personne ne soit surpris à leur sujet.
- Le **minimum viable agreement** consiste à avoir juste ce qu’il faut pour aligner les équipes avec les objectifs de l’organisation.
  - On a besoin de cet alignement, et d’un autre côté on veut éviter la formalisation pour ne pas étouffer l’initiative des équipes, d’où le côté _minimum viable_.
  - Les CFRs et la technology strategy font partie des techniques qui permettent d’établir ce minimum viable agreement.
- Les **Cross-Functional Requirements** (CFRs) sont la technique la plus spécifique, et la moins directive contribuant à établir un minimum viable agreement. C’est le “What”.
  - Parmi les types de CFRs, on trouve de manière non-exhaustive : la performance, la scalabilité, l’availability, la sécurité, l’accessibilité, l’observabilité etc.
  - Ce qui compte, ce n’est pas d’être exhaustif, mais d’**établir les CFRs qui sont importants dans notre domaine**. Par exemple, un programme de voyage spatial la maintenabilité peut être moins importante que l’availability.
  - Les CFRs doivent être associés à des **tests d’acceptation**, **exécutables automatiquement ou à la main**, pour pouvoir valider que le CFR a été implémenté.
  - Les CFRs suivent un formalisme, par exemple :
    - CFR :
      - **As a** DEVELOPMENT TEAM MEMBER
      - **I want** to read access to and the ability to search ACCESS LOGS in standard LOG FORMAT, using the STANDARD OBSERVABILITY TOOLSET
      - **So that** I can monitor the operation of my systems and debug problems.
    - Acceptance tests associés :
      - Test 1 :
        - **Given** the system is running
        - **When** the system is accessed
        - **Then** a single log entry is written to STDOUT in the STANDARD LOG FORMAT.
      - Test 2 :
        - **Given** the system has been accessed
        - **When** the access log entry is written
        - **Then** that log entry is visible in the STANDARD OBSERVABILITY TOOLSET and displays the correct access information.
      - etc.
    - Le CFR et les tests contiennent les expressions en majuscules pour faire **référence à un glossaire** spécifique à l’entreprise.
    - Un des avantages du formalisme c’est qu’on peut difficilement justifier de passer plus de temps à implémenter le CFR que ce qui est nécessaire pour remplir les critères d’acceptation.
  - Les CFRs peuvent se cumuler, on peut notamment en écrire un autre pour adresser un cas particulier non couvert par le CFR plus général.
- La **technology strategy** est une formulation de la manière dont le département tech peut contribuer à la mission de l’organisation. A l’opposé des CFRs, elle est très générale mais directive. C’est le “How”.
  - L’idée est qu’on va poser des paris qui, s’ils sont suivis, vont (on l’espère) mener à l’outcome souhaité pour l’organisation. On va donc prioriser en se basant sur la stratégie.
  - Pour permettre de faire des choix, il est crucial que la stratégie indique ce qu’on privilégie, et donc aussi **ce qu’on choisit de ne pas privilégier**.
    - Petit tip : si l’opposé de notre stratégie paraît absurde, c’est qu’on n’a pas de stratégie.
    - La formulation peut par exemple être : _we emphasize X, even at the expense of Y_.
  - La stratégie peut **aller plus ou moins loin dans ce qu’elle prescrit**, en se basant sur les besoins de son contexte. Par exemple, choisir le langage de programmation peut être un choix stratégique dans une entreprise, et plutôt secondaire dans une autre qui a un business où elle peut se le permettre.
  - La stratégie peut se complexifier et **donner des réponses en fonction de situations** : par exemple une entreprise qui choisit AWS comme cloud vendor pour ses microservices, et qui découvre que GCP vaut bien plus le coup pour la partie data, peut enrichir la stratégie avec ces deux choix en fonction du type de service à implémenter.
  - La technology strategy peut se manifester par une page de texte, mais aussi par des des choses mises en place :
    - Level 0 : juste du texte pour exprimer la stratégie à suivre.
    - Level 1 : on redirige l’équipe qui en a besoin vers un expert qui peut aider à implémenter un élément particulier de la stratégie.
    - Level 2 : on request : on met à disposition une personne ou un groupe de personnes au besoin. Ils ont éventuellement mis en place de l’automatisation, mais leur intervention est nécessaire.
    - Level 3 : self-service : une équipe platform maintient des ressources (job à faire tourner, API à appeler, librairie à utiliser etc.) qu’une équipe peut utiliser en autonomie pour qu’elle puisse mettre en œuvre l’élément stratégique.
  - L’auteur conseille **_Enterprise Architecture as Strategy_** de Jeanne W. Ross, Peter Weill, David Robertson.

### 10 - Collectively Sourced Architectural Principles

- Les **collectively sourced architectural principles** permettent de compléter la technical strategy par **des éléments plus précis**.
  - De même que la technology strategy, ils vont permettre de donner un cadre pour prendre des décisions décentralisées.
- Il est important que ces _architectural principles_ soient construites en récoltant des **inputs d’un grand nombre de personnes** représentant l’ensemble des équipes et des rôles.
  - Ca permet à la fois d’éviter qu’on pense que ces principes sont imposés d’en haut, et à la fois d’obtenir de meilleurs principes.
- Leur contenu :
  - Les principes doivent contenir :
    - **Principle** : description du principe.
      - Ex : _Value independence of teams most highly_
    - **Subtitle** : indique l’action principale sous-tendue par le principe.
      - Ex : _Split solutions along team lines_
    - **Rationale** : en quoi ça consiste et en quoi ça va dans le sens de la stratégie technique.
    - **Implications** : des points importants, positifs ou négatifs, dont on assume les conséquences explicitement.
  - Il en faut **entre 8 et 15**, pour à la fois couvrir l’ensemble des objectifs stratégiques, et à la fois tenir dans la tête de chacun.
  - Les différents principes ne doivent pas être contradictoires, mais il est normal qu’il y ait **une certaine tension** entre eux. Cette tension représente à la fois la marge de manœuvre des équipes, et en même temps les pousse à **prendre la responsabilité** s’ils veulent l’assumer.
    - Par exemple, _Value independence of teams most highly_ et _Cloud native means our cloud_ comportent une certaine tension pour une équipe qui veut déployer son propre cluster Kafka plutôt qu’utiliser celui proposé par leur plateforme. Elle peut le faire si elle a de bonnes raisons, en assumant la responsabilité que ça comporte.
  - Les bons principes :
    - Sont **liés explicitement aux objectifs stratégiques** d'entreprise.
    - Disent **comment** faire ce qui est décrit.
    - Donnent des critères clairs pour **choisir entre plusieurs options dans une décision d’architecture**, et donc ils sont :
      - Specific
      - Mesurable
      - Achievable
      - Realistic
      - Testable
  - Les mauvais principes :
    - Il ne faut **pas choisir des pratiques** plutôt que des principes.
      - Par exemple le TDD, le trunk based development, le pair programming. Les pratiques ne permettent d’aider à choisir entre deux approches d’implémentation de micro-frontends ou entre self-hoster un Lucene versus utiliser une version managée sur AWS.
    - Il ne faut **pas choisir des CFRs **plutôt que des principes.
      - Les CFRs sont très spécifiques et non négociables, là où les principes sont plus lâches et indiquent **comment on fait les choses d’habitude**.
- Les principes aident à prendre les décisions d’architecture.
  - A chaque fois qu’on a une décision à prendre, on peut faire le tour des principes pour vérifier lesquels s’appliquent à notre cas.
    - Si tous s’appliquent, c’est qu’on est en train de prendre une décision trop grande, et qu’il faudrait sans doute la découper en plus petites.
  - Les principes permettent de restreindre les options, mais aussi de potentiellement les étendre, en rappelant les objectifs communs qu’on n’avait peut-être plus en tête au moment de lister les options.
  - Les implications des principes peuvent aider à compléter les implications des options.
  - Une fois qu’on adopte les architecture principles, on peut ajouter **une section à notre template d’ADR pour indiquer les principes qui s’appliquent** à la décision.
- Un **workshop** pour créer les architectural principles :
  - Les _architectural principles_ doivent être créées en impliquant l’ensemble des personnes qui seront amenées à prendre des décisions d’architecture.
    - L’auteur conseille de s’inspirer de **_Art of Scalability_** de Martin Abbott et Michael Fisher : les équipes qui devront appliquer les principes doivent avoir une impression d’ownership sur eux.
  - Concernant les ressources pour faciliter une série de workshops, l’auteur conseille :
    - L’article Workshop Wisdom
    - Le livre **_Collaborative Software Design_**
  - **Étape 1 : on prépare les inputs.**
    - On va d’abord chercher les **objectifs et la vision de l’organisation**.
      - Si on a de la chance, ça peut être sous forme de document, sous forme d’objectifs d’outcome / impact.
      - Si on a moins de chance, il va falloir chercher sur le site de l’organisation, dans les annonces publiques etc.
        - On peut ensuite aller voir des executives (CTO, CPO, Chief scientist) pour leur demander les objectifs d’entreprise.
        - Et enfin on peut aller voir les personnes en dessous (par exemple chief architect) pour confirmer et affiner les objectifs.
    - On va ensuite les **classer en 3 thèmes**.
      - Ces thèmes doivent, à eux trois, recouvrir l’ensemble des objectifs de l’organisation, et ils doivent être mutuellement exclusifs (ne pas recouvrir les mêmes aspects).
      - Exemple : Operational excellence, Customer responsiveness et Product leadership.
      - Si on n’arrive pas à facilement tirer ces 3 thèmes, l’auteur propose des thèmes génériques qui décrivent les objectifs que les organisations poursuivent généralement, répartis en 2 catégories :
        - Grow our impact
          - Expand to complementary products
          - Expand to new markets/regions
          - Expand customer segments
          - Inorganic growth
        - Grow our impact
          - Expand to complementary products
          - Expand to new markets/regions
          - Expand customer segments
          - Inorganic growth
  - **Étape 2 : on organise le workshop.**
    - On va être le facilitateur du workshop.
    - 1 - On invite les participants.
      - On doit inviter les développeurs, infra, ops, architectes, ux, PMs etc. Il faut **au moins une personne de chaque équipe**, et au moins **un représentant pour chaque rôle**.
      - Il faut faire attention à ne pas sur ou sous-représenter un rôle en particulier.
      - L’auteur a déjà fait un tel workshop avec plus de 100 personnes, mais il vaut mieux en inviter autant qu’on pense pouvoir en gérer.
    - 2 - On book le meet.
      - On peut soit faire un workshop de 3 heures, soit 2 de 1.5 heures (ce qui est préférable).
      - Une fois confirmé, on peut envoyer un email avec l’ordre du jour.
    - 3 - On prépare l’espace de travail.
      - Il nous faut 5 espaces :
        - _Welcome area_ : on y affiche l’ordre du jour et l’objectif.
        - _Definitions and criteria area_ : on y affiche la définition d’un principe d’architecture, et les caractéristiques qu’il doit avoir (Specific, Measurable, Achievable, Realistic, Testable).
        - _Collaborative working area_ : on y met un graphique avec 3 cercles pour les 3 thèmes de principes d'architecture, sur lequel on va venir coller des post-its.
          - Les 3 cercles se débordent les uns sur les autres parce qu’un principe peut appartenir à 1, 2 ou 3 thèmes, même si les thèmes sont en eux-mêmes mutuellement exclusifs dans leur signification.
        - _Working group breakout areas_ : on les place autour de la _collaborative working area_. Il faut y avoir des post-its, pour que les personnes qui y travaillent en petits groupes puissent les déplacer vers la _collaborative working area_.
        - _Parking lot_ : on va y mettre les post-its hors sujet pour des discussions futures.
  - **Étape 3 : on lance le workshop.**
    - **1 - Kickoff** (10mn) :
      - On explique le but du workshop, les critères des bons principes d’architecture, le but de chaque espace de travail.
      - On rappelle les objectifs de l’organisation, et les 3 thèmes qui en sont issus, et dans lesquels devront rentrer les principes.
      - On finit par organiser les participants en groupes, avec l’idée que chaque groupe devra avoir une représentation variée. On peut demander aux participants de se regrouper (ou regrouper leurs noms si c’est en virtuel) par rôle, pour ensuite faire des groupes mélangés.
        - On peut aussi simplement expliquer ce qu’on veut, et laisser le groupe se diviser de lui-même.
    - **2 - Split** (30 mn) : les groupes vont écrire le plus de principes possibles.
      - Chacun écrit individuellement ce qui lui passe par la tête, puis revient dans son groupe pour dédupliquer.
      - Il faut bien leur rappeler que les principes doivent être SMART, et donc des principes comme KISS ou DRY ne vont pas.
    - **3 - Reconvene** (20 mn) : chaque groupe va désigner quelqu’un pour présenter leurs principes, d’une manière suffisamment détaillée pour qu’ils puissent les récupérer pour eux s’ils le veulent.
    - **4 - Split** (30 mn) : chaque groupe met à jour ses principes, à la lumière de ce qu’il a entendu des autres.
      - C’est tout à fait OK de copier des principes des autres groupes. Chaque groupe doit avoir au moins 8 principes.
      - C’est aussi à cette étape que les groupes vont essayer de classer leurs principes dans les 3 thèmes : chaque principe peut être dans 1, 2 ou 3 thèmes. Il faut faire attention à ce que **l’ensemble des principes soit équilibré vis-à-vis des thèmes**.
    - Si on fait le workshop sur 2 jours différents, c’est ici qu’on fait la coupure.
    - **5 - Reconvene** (20 minutes) : chaque groupe présente à nouveau ses principes aux autres, et les place sur le graphique à 3 cercles pour indiquer dans quels thèmes il rentre.
      - Si des principes ont été récupérés d’autres groupes, les groupes expliquent pourquoi, et on regroupe les post-its.
    - **6 - Dot-voting** (5 minutes) : chaque participant va voter pour 8 tickets avec des points de la même couleur.
      - Avant le vote, on rappelle les objectifs de l’organisation, et ce à quoi vont servir les principes d’architecture.
      - A la fin du vote, on écrit le résultat de chaque ticket, et on sélectionne les 15 tickets avec le plus de votes.
    - **7 - Consider implications** (20 minutes) : chacun va enfiler son chapeau “cautious”, pour examiner les points négatifs des principes sélectionnés, et les écrire avec des post-its d’une autre couleur.
      - Si un principe n’a aucun point négatif, alors il est soit trop général pour servir ensuite à prendre des décisions, ou alors on l’idéalise collectivement et c’est problématique.
      - On les encourage à mettre toutes les raisons négatives qu’ils ont en tête.
      - Une fois les post-its placés, on les lit et on s’assure qu’ils sont clairs pour tout le monde, mais on n’en discute pas.
    - **8 - Dot-voting** (5 mn) : on vote à nouveau avec 8 points chacun, d’une couleur différente.
      - C’est ce vote qui sera le vrai vote, le 1er vote était là surtout pour mettre la lumière sur les principes les plus en vus, avant de prendre du recul et de faire un choix final collectif.
      - Une fois le vote fait, on compte les points, et on met en avant les 8 à 15 post-its avec le plus de votes.
    - **9 - Commit to adoption** (10 minutes) : on demande au groupe de faire un commitment sur ces principes.
      - On demande si certaines personnes ont encore des soucis avec certains des principes sélectionnés, si oui ils les mettent sous forme de post-its : on leur dit que leurs remarques seront intégrées malgré le fait que le principe sera adopté. Il s‘agit d’une forme de “disagree and commit”.
  - **Étape 4 : on présente les principes à l’ensemble du département.**
    - L’auteur conseille de les mettre dans un wiki, une page pour servir de hub, et une page par principe.
      - La page de hub :
        - Contient des liens vers les pages de principes.
        - Puis contient du contexte, avec les 3 thèmes stratégiques décrits succinctement, la définition d’un principe d’architecture, et ses caractéristiques (SMART etc.).
        - La photo du diagramme en camembert du workshop, où sont listés les principes avec leur appartenance à chacun des 3 thèmes, montrant bien que chaque thème est bien représenté.
        - Enfin, une section pour comprendre comment les principes ont été obtenus, avec les participants au meeting, les principes non choisis par le dot-voting, et les post-its de réserve.
          - Cette partie est utile pour **transformer la page en hub “culturel”**, alimentant le minimum viable agreement comme élément partagé.
      - Chaque page de principe :
        - Contient les éléments du principe : le titre, le sous-titre, le _rationale_, et les implications.
        - On y ajoute le ou les thèmes auxquels le principe appartient. Le _rationale_ indique justement les avantages du principe par rapport aux thèmes.
        - On y ajoute une section _background_ pour indiquer dans quelles conditions le principe a été adopté, et quelles réserves ont été soulevées le concernant.
    - Une fois les principes rédigés dans le wiki, on les partage avec les participants de l’atelier qui a servi à les construire pour recueillir des feedbacks pendant un temps limité. Une fois le temps écoulé, on fait les éventuelles corrections suite aux feedbacks, et **les principes deviennent officiels, on les partage alors avec tout le département**.
    - On peut créer un petit ADR pour signaler l’adoption de l’ensemble des principes. On utilisera par la suite aussi les ADRs en cas de modifications.
- Les principes doivent rester à jour, que ce soit **vis-à-vis de la technical strategy**, ou **vis-à-vis des feedbacks venant des décisions d’architecture** qu’elles aident à cadrer.
  - Il est tout à fait possible, et même normal qu’**une décision d’architecture aille contre un principe**, par exemple utiliser un autre cloud provider pour une feature qui n’est pas sur Heroku, alors que le principe dit d’utiliser Heroku. Dans ce cas, il faut bien le mettre en avant dans l’ADR, et l’indiquer aux advisors.
  - Quand des décisions vont contre un même principe **de manière répétée**, il est probablement temps de le modifier, **soit à la marge** en précisant des choses, ajoutant ou des implications etc. **soit en remplaçant le principe** par un plus adapté.
  - Parfois, **un principe manque** : quand des ADRs ne font régulièrement référence à aucun principe, ou quand on a un même sujet de fond qui refait surface régulièrement au gré des ADRs, c’est qu’il faut ajouter le principe manquant.
  - **Certains principes sont de trop** : si on se rend compte au bout d’un moment que certains principes ne sont jamais référencés par les ADRs, il vaut mieux les enlever.
- **La modification, l’ajout ou la suppression d’un principe se fait via un ADR**.
  - L’auteur conseille d’y appliquer une procédure plus rigoureuse que pour les autres décisions, en utilisant soit la procédure démocratique, soit la procédure _consent_ où chacun peut poser son véto. Le but est de garder intact le commitment vis-à-vis des principes.
  - N’importe qui peut proposer une modification des principes, pas seulement les architectes.
- Vu que les ADRs sont des documents immutables et qu’ils pointent vers des principes qui peuvent changer, il faut **garder une version legacy des principes** pour garder les ADRs compréhensibles.
  - On peut faire ça en créant une copie de chaque principe qui est supprimé ou modifié, en ajoutant par exemple [RETIRED] et [OUT-OF-DATE] au titre de la page du principe déprécié pour faciliter leur mise de côté. Les ADRs peuvent alors continuer de pointer vers ces pages de principe legacy.
- Bien qu’hors de la portée de ce livre, l’auteur signale que les décisions répétées allant dans le même sens devraient aussi pouvoir mener à d’éventuelles modifications de la _technical strategy_, voire même des objectifs d’organisation.

### 11 - Using a Technology Radar

- L’objectif du _technology radar_ est de créer une **représentation actuelle de ce que l’organisation pense des technologies et techniques existantes**, en se basant sur les expériences de l’ensemble des membres.
  - Le radar ressemble à un radar de tour d’observation d’avions, et montre le mouvement des technologies, pouvant passer de “conseillées” à “à éviter”.
- **Chez Thoughtworks** :
  - Le _technology radar_ est mis à jour tous les 6 mois.
  - Pour qu’une technologie ou une technique soit ajoutée au radar, il faut qu’au moins une équipe y ait été exposée via un projet client.
  - Chaque point est placé :
    - 1 - En fonction de la proximité au centre : plus c’est proche, plus la techno est recommandée :
      - _Hold_ : on fait attention si on veut l’utiliser.
      - _Assess_ : vaut la peine d’être exploré.
      - _Trial_ : vaut la peine d’être essayé, mais n’est pas le choix par défaut.
      - _Adopt_ : devrait être adopté par défaut si l’usage s’y prête.
    - 2 - Par thématique : ils ont choisi 4 cadrans : _techniques_, _tools_, _platforms_, _language and frameworks_.
  - Chaque point est marqué selon son évolution par rapport au précédent radar : soit il est nouveau, soit il n’a pas bougé, soit il a bougé vers l’intérieur ou vers l’extérieur.
  - Chaque point a un texte descriptif qui lui est associé, et on peut consulter sa description et son statut dans les précédentes versions du radar pour voir son évolution.
- **Une entreprise lambda** ne va pas avoir exactement le même type de radar que Thoughtworks :
  - Thoughtworks est une entreprise de consulting qui fait le radar notamment pour conseiller ses clients. Si l’entreprise qui fait le radar a **des produits en interne**, ceux-ci pourront y apparaître.
  - Pour la même raison, les 4 couches en partant du centre vers l’extérieur pourront devenir : _Adopt_, _Trial_, _Hold_ et _Retire_.
- Le radar peut **s’intégrer aux ADRs** comme pour les _architectural principles_ : une section du template d’ADR peut lister les technologies impliquées dans une décision.
  - Ca peut par exemple aider les décideurs à aller **demander des advices aux bonnes personnes** en voyant que celles-ci ont déjà pris des décisions impliquant des technologies auxquelles ils font face eux-mêmes.
  - Le fait qu’une technologie soit choisie dans un ADR alors qu’elle n’est pas conseillée dans le radar ou n’y apparaît pas est un **signe de tension entre le cadre que représente le radar et la décision individuelle**. Ça doit être mis en valeur pour que les advisors en prennent la pleine mesure. A l’inverse, si on utilise des technologies conseillées par le radar, on sait que notre décision est plutôt consensuelle.
- Le radar sert de cadre aux décisions, mais **les décisions peuvent aussi servir à mettre à jour le radar**.
  - 1 - Si la décision est d’utiliser une techno moins recommandée à la place d’une qui était recommandée par le radar, peut être qu’il faut mettre à jour la position de ces deux technos. Et si une nouvelle techno émerge lors d’une décision, peut être qu’il faut l’ajouter au radar.
  - 2 - La mise à jour du radar peut être l’objet d’une initiative stratégique spécifique (ie. concernant la _technology strategy_) pour investir dans telle ou telle technologie.
- **Comment créer son propre radar** :
  - Thoughtworks met à disposition un outil “build your own radar” (BYOR) pour qu’on puisse faire un radar similaire au leur, à partir de nos informations. On remplit un tableur, et on peut générer le radar à tout moment avec le contenu du tableur pour voir à quoi ça ressemble.
  - **Étape 1 : on va collecter les technologies à mettre dans le radar.**
    - Comme pour les _architectural principles_, il faut impliquer le plus de monde possible. Mais dans le cas de cette étape de la construction du radar, l’**asynchrone** fonctionne bien.
      - Si l’organisation est trop grande pour impliquer toutes les équipes produit, on peut choisir certains produits, et impliquer tous ceux qui y contribuent : développeurs, ops, UX, PM, QA, security, data. Les RH et la finance devraient être hors du champ.
    - Une fois qu’on a les personnes, on leur partage un tableur, et on leur demande d’ajouter les **technologies utilisées actuellement au sein de l’organisation**, avec une description, la thématique, et la proximité avec le centre du radar.
      - On note aussi qui ajoute chaque technologie, pour pouvoir retourner voir la personne si quelque chose n’est pas clair.
    - L’objectif à cette étape est de **récolter le maximum d’éléments**, la déduplication se fera par la suite.
  - **Étape 2 : on trie et on valide les technologies récoltées.**
    - Cette étape est faite par l’organisateur.
    - Tâches à faire :
      - 1 - On vérifie que chaque techno est bien mise à “new” vu que c’est le premier radar.
      - 2 - On remplit ce qui manque, par exemple les thématiques manquantes.
      - 3 - On clarifie la description en faisant appel à l’auteur en cas de besoin.
      - 4 - On regroupe les éléments qui font référence à la même chose. Mais **on ne déduplique pas à cette étape**.
      - 5 - On regroupe les technos liées entre-elles.
      - 6 - On regroupe par thématique.
      - 7 - On regroupe par proximité avec le centre du radar.
  - **Étape 3 : on examine chaque technologie de plus près.**
    - Cette étape se fait de manière **synchrone**, avec le groupe qui a contribué initialement, et prend 4 heures (on peut toujours faire 2 x 2 heures). S’il y a trop de personnes, on peut prendre un représentant de chaque équipe ou rôle.
    - On passe sur chaque techno, **on clarifie la description, et on voit si on peut fusionner avec d’autres** qu’on avait regroupé à l’étape précédente.
      - Les différentes versions majeures d’une même dépendance ne doivent pas être fusionnées. Elles permettront de montrer la direction dans laquelle on pense qu’on doit aller.
    - On s’assure aussi de correctement placer les technos par rapport aux thématiques.
      - La thématique des techniques va en général commencer par être plutôt vide, et va se remplir au gré des discussions.
  - **Étape 4 : on place les technologies par rapport au centre du radar.**
    - Cette étape se fait de manière **asynchrone**, avec tous ceux qui ont ajouté des technologies, et aussi ceux qui ne l’ont pas fait mais auraient pu.
    - On ajoute une colonne de vote par personne au tableur contenant les technologies triées. Chaque personne va **voter** pour indiquer dans quel _ring_ (trial, adopt, hold ou retire) se trouve chaque technologie.
      - Les votants peuvent aussi ajouter des commentaires à la description de chaque technologie s’ils en ont encore.
    - Une fois les quelques jours de vote passés, on clôture le vote et on note le _ring_ résultant des votes pour chaque technologie.
  - **Étape 5 : on formalise la description des technologies.**
    - Cette étape est d’abord faite par l’organisateur : il va rédiger un texte clair et concis pour chaque technologie, à partir de la description et des commentaires. Les points de tension ou de conflit doivent aussi transparaître.
    - Une fois que c’est fait, il partage le document en interne pour un dernier round de commentaires de feedback sur la formulation finale.
  - **Étape 6 : on publie le radar.**
    - On peut utiliser le service gratuit de Thoughtworks, ou héberger notre radar nous-mêmes.
    - Une fois hébergé, on l’envoie par email à l’ensemble du département pour qu’ils commencent à l’utiliser pour prendre leurs décisions.
- Il faut **mettre à jour le radar** régulièrement.
  - La première manière est d’**organiser des sessions de mise à jour régulières**, par exemple tous les trimestres ou tous les semestres.
    - 1 - On copie le tableur qui a servi à faire la dernière version de radar, en mettant chaque techno comme n’étant pas nouvelle.
    - 2 - On demande des contributions asynchrones pour de nouvelles technologies, ou des informations supplémentaires dans la description des technologies existantes en fonction des usages qui ont pu être faits.
      - Il est probable que les nouvelles technos finissent dans le ring _trial_.
      - Le nombre de techniques devrait être plus important que pour la 1ère fois.
    - 3 - On trie et on valide les nouvelles technologies.
    - 4 - On examine chaque nouvelle technologie dans un meeting de 2 heures tous ensemble.
    - 5 - On place les nouvelles technos par rapport au centre, là encore avec un vote.
    - 6 - On formalise les technologies nouvellement arrivées et on met à jour la description des autres technos qui ont eu du changement.
  - La 2ème manière est de **faire remonter des changements de technologie depuis les décisions individuelles** qui sont prises.
    - Toute décision qui ajoute une technologie qui n’est pas dans le radar, ou qui utilise une technologie d’une manière qui est en contradiction avec la position de celle-ci dans le radar (notamment son _ring_), est une décision significative qui peut donner lieu à un ADR pour ajouter la techno au radar.
- On peut faire des **pages d’historique pour chaque technologie**, de la même manière que Thoughtworks : à chaque nouvelle version d’une technologie (description, _ring_ etc.), on ajoute un paragraphe en haut de la page pour décrire les changements.

## Part III - Finding Your Way Through the Decision Landscape

### 12 - The Art of Deciding

- Les aspects **psychologiques et sociaux** affectent tout autant une décision que les aspects purement rationnels.
- La **section _Context_** permet de **fixer le cadre de la décision**, aussi bien d’un point de vue technique qu’humain.
  - Il permet de **se limiter à ce qui est le plus important** pour la décision, pour concentrer notre attention dessus.
    - On y cadre la discussion vers les points importants ou bloquants pour la décision.
    - On y cadre le temps pendant lequel la décision sera valide, et le temps qu’on a pour implémenter. Par exemple Google considère qu’ils architecturent leur systèmes pour supporter un scale de x10, mais pas au-delà.
  - On peut utiliser les 3 questions de Joseph Badaracco pour comprendre et mieux cadrer notre contexte :
    - _Quelles sont mes obligations ?_ => il faut identifier vis-à-vis de qui, dans l'organisation et hors de l’organisation, nous avons des obligations pour cette décision.
    - _Qu’est-ce qui restera tel quel dans tous les cas ?_ => ça nous force à considérer les choses telles qu’elles sont, plutôt qu’imaginer la décision prise dans un monde idéal.
    - _Qui sommes-nous ?_ => il faut se remettre en tête les valeurs de notre organisation pour aller dans la bonne direction.
  - Le contexte aide aussi à **impliquer les bonnes personnes** dans la décision :
    - Si on a trop de personnes affectées et expertes à aller voir, c’est peut être que notre décision essaye de changer trop de choses et qu’il faudrait la subdiviser.
    - Ou peut-être qu’on implique trop de monde par obligation sociale perçue, par exemple des supérieurs hiérarchiques qui ne sont ni affectés ni experts du sujet.
- Les **sections _Options_ et _Consequences_** permettent de mettre en évidence les **futurs possibles du système**.
  - Cette activité doit être **créative** : il faut envisager toutes les options qui nous passent par la tête sans s’auto-censurer d’office, et sans avoir peur de perdre son temps dans cet exercice.
  - Pour essayer d’être créatif, on peut se poser ces deux questions :
    - Est-ce que je mets de côté une autre option ?
    - Cette option aurait-elle des variantes pertinentes ?
  - Pour trouver de l’inspiration, on peut :
    - **Réfléchir par soi-même** en passant en revue les options. L’auteur conseille de **gribouiller des choses, des schémas et autres**, pour passer d’une idée à une autre facilement en traçant des traits par exemple.
    - **Chercher dans des documents**, par exemple des ADRs, ou encore des livres de design patterns ou autres.
    - **Demander des advices.**
- La **section _Advice_** permet d’**affiner le contexte et les options**.
  - On répond aux deux autres questions de Badaracco :
    - Quelles seront les conséquences de mes options ?
    - A quel point on sera OK pour rester avec chacune des options ?
  - Quand la confiance et la sécurité psychologique sont élevées, les advices permettent d’améliorer le contexte, parce qu’on :
    - Fait appel à des **perspectives différentes**, nous permettant de trouver nos _unknown unknowns_.
    - Fait appel à** l’intuition des personnes**, et certaines d’entre-elles arrivent à voir les choses venir.
  - L’auteur évoque le livre **_Decisive_** de Chip et Dan Heath, avec leur framework WRAP, que les advices permettent de suivre :
    - _Widen your options_ : chercher de l’inspiration à l’intérieur et à l'extérieur.
    - _Reality-test your assumptions_ : se poser la question de savoir si on n’est pas en train de se restreindre sur des options en pensant que certains groupes sont contre, ou à l’inverse si on envisage des options sans prendre en compte certaines conséquences négatives.
    - _Attain distance before deciding_ et _Prepare to be wrong_ sont plutôt de l’ordre de l’émotionnel et de la métacognition : se préparer au fait de subir des critiques.
- Pour **donner et recevoir de meilleurs advices**, il faut **travailler sa métacognition** (comprendre ses propres pensées). Ces compétences devront être acquises petit à petit par l’ensemble de l’organisation.
  - Pour plus de détails sur ce sujet, l’auteur renvoie à **_Learning Systems Thinking_** de Diana Montalion.
  - **Exercice 1 : Share your Reasons**
    - On va essayer de **comprendre les raisons qui nous ont convaincu d’une idée**. On va découvrir qu’on se base souvent sur des choses autres que les faits ou la rationalité.
    - Exemple : on pourrait avoir une tendance à privilégier les outils qu’on a soi-même expérimenté. Ou on pourrait privilégier les solutions venant d’une personne qu’on estime.
  - **Exercice 2 : Are You Reacting or Responding?**
    - Il s’agit de conscientiser à quel moment on **réagit à des pensées et sentiments qui nous viennent**, et à quel moment on **prend le temps de les analyser** pour réagir seulement ensuite.
    - En analysant les moments où on est en réaction immédiate, on va plus facilement remarquer des choses comme le fait de traiter ce que disent les gens différemment selon si on les apprécie ou non.
    - L’advice process permet de **prendre son temps** pour prendre en compte ce qui est dit et l’incorporer, en ayant nos biais en tête.
  - **Exercice 3 : Intentionally Seek Advice That Challenges You.**
    - Il s’agit de chercher **délibérément à parler aux personnes qui ont des idées contraires aux nôtres**, ou à considérer des arguments contraires à nos idées.
    - Pour considérer les idées avec lesquelles on est en désaccord, il faut :
      - D’abord être au clair avec l’exercice 1 : les raisons pour lesquelles on préfère nos idées actuelles.
      - Se préparer à avoir tort.
    - Il est intéressant d’examiner pourquoi on est réticent à parler à certaines personnes : est-ce qu’on a un problème personnel avec elles ? Est-ce qu’on a peur qu’elles nous mettent en difficulté sur nos certitudes ? Est-ce qu’on a peut qu’elles mettent en avant un manque de compétence chez nous ?
  - Parfois on a affaire à des **personnes qui ne veulent pas coopérer** dans l’advice process.
    - Ça peut typiquement être des **enjeux de pouvoir liés à une position où la personne a des connaissances sur une codebase et son histoire**, et où elle est réticente à donner les raisons sous-jacentes de son opinion pour en faire un advice de qualité.
    - Alberto Brandolini a fait un article décrivant ce genre de personne : [The Rise and Fall of the Dungeon Master](https://medium.com/@ziobrando/the-rise-and-fall-of-the-dungeon-master-c2d511eed12f).
    - La 1ère chose à faire face à ces personnes, est de suivre les techniques de métacognition données ici, et aussi d’essayer de faire comprendre à la personne que la contribution au collectif a aussi beaucoup de valeur.
    - Si ça ne fonctionne pas, on peut :
      - Demander à une autre personne qui a une bonne relation avec la personne d’aller recueillir l’advice à notre place.
      - Passer en mode asynchrone, et discuter via chat ou commentaires d’ADR.
    - Si ça ne fonctionne toujours pas et que la personne refuse de jouer le jeu de l’advice process :
      - On peut écrire dans la section Advice de l’ADR que la personne refuse de donner l’advice.
      - On peut escalader à la personne qui a mis en place l’architecture advice process dans l’organisation (probablement un architecte), pour donner plus de poids auprès de la personne qui refuse de coopérer :
        - 1. Rappeler le fonctionnement de l’advice process.
        - 2. Rappeler le contrat social et les responsabilités de chacun.
        - 3. Rappeler que l’ADR permet de rendre l’accountability claire, et met en lumière ce qui a été considéré et ce qui a été choisi.
    - Ce genre d’interaction tendue est un bon moment pour ensuite faire une analyse de “métacognition postmortem”, pour apprendre de la situation et progresser.
- **Prendre une décision** est une activité nécessaire, qu’on a parfois tendance à ne pas vouloir assumer.
  - Marquer une décision comme irréversible est un bon moyen de la remettre à plus tard à peu de frais. Dans les faits, **une décision est rarement irréversible**.
  - Il vaut mieux **décider intentionnellement de ne rien faire**, plutôt que de remettre la décision à plus tard. Ça permet de garder le pouvoir.
  - Une des raisons principales pour ne pas prendre une décision est **la peur**. On appelle ça en général l’_analysis paralysis_.
    - Ce sujet est largement couvert dans **_The Art of Decision Making_** de Joseph Bikart.
    - Parmi les peurs possible proposées par Bikart, il peut y avoir :
      - _Fear of failure_ : peur que l’option choisie se révèle être la mauvaise, sans qu’on ne puisse le savoir à l’avance.
      - _Fear of heights_ : peur que ça marche trop bien, et d’être victime du succès.
      - _Fear of identification_ : peur de l’association permanente avec la décision prise : “Ah oui, c’est la personne qui nous a fait passer d’AWS à GCP”.
      - _Fear of lack of recognition_ : peur que la décision soit vue comme prise par le collectif sans qu’on n’en tire aucune gloire.
      - _Fear of selfishness_ : peur que la décision soit perçue comme ayant été prise pour des raisons égoïstes.
    - Ces peurs sont **irrationnelles**. Il faut prendre son courage à deux mains et prendre la décision malgré tout.
- L’auteur conseille de **sonder nos propres biais**, les noter quelque part, et **se les relire avant de prendre une décision**.
  - Parmi les biais courants qu’il remarque :
    - Biais à propos des probabilités mal évaluées.
    - Biais à évaluer les outcomes sur des critères arbitraires qui nous sont propres.
    - Biais d’aversion aux pertes.
    - Biais de privilégier les idées venant du groupe auquel on appartient.
    - Biais des coûts irrécupérables.
- **Prendre une décision est difficile, qu’on soit celui qui la prend**. Pour aider à le faire, on peut d’abord **écrire la décision en privé**, et la relire dans des conditions optimales : un endroit calme, un temps calme.
  - Si possible, l’auteur conseille de laisser passer la nuit, pour que la décision soit plus claire pour nous, et plus facile à assumer.
- **Pour les architectes** qui avaient l’habitude de prendre les décisions, **laisser le pouvoir est encore plus difficile**.
  - L’auteur raconte une fois où ils avaient mis en place l’advice process avec un collègue architecte. Une des équipes devait prendre une décision quant à la technologie à utiliser pour un nouveau service. Malgré les advices contraires insistants des deux architectes, ils étaient partis sur AWS Lambda. L’auteur avait voulu intervenir pour empêcher la décision, mais l’autre l’en a empêché : ça aurait brisé la confiance, le contrat social de l’advice process.
  - Avec l’advice process, **le rôle de l’architecte se transforme** : de décisionnaire sur l’architecture, il passe à celui qui s’assure que les décisions se multiplient et se prennent dans de bonnes conditions, qui s’assure que “les conversations qui ont besoin d’avoir lieu ont lieu” (cf. citation de Ruth Malan).
  - Quelques conseils pour un architecte :
    - Il doit apprendre aux autres tout ce qu’il sait de l’architecture.
    - Il doit donner des vrais advices.
    - Il ne doit pas essayer d’être dans toutes les décisions.
    - Il doit laisser les autres faire leurs propres erreurs, et les aider.
    - Il doit aider les autres à écrire de bons ADRs.
    - Il doit veiller à cultiver la confiance dans l’organisation.
    - Il doit coacher chacun sur la nature de l’advice process, qui est de se faire confiance dans la prise de décision.
    - Il doit aider à séparer les tensions saines de celles qui ne le sont pas.
    - Il doit s’assurer que ceux qui ont du mal à s’exprimer ou se mettre en avant puissent le faire.
    - Il doit sonder ses propres émotions, et apprendre d’elles.

### 13 - Tackling Architectural Variability

- La **variability** est l’absence de prédictibilité, due au fait qu’on ne sache pas ce qu’on va implémenter, ni combien de temps ça prendra. Elle représente **les inconnues** qu’il faut adresser dans un système.
- L’architecture logicielle permet **à la fois d’adresser la _variability_, et en même temps en créer de la nouvelle** en introduisant de nouvelles inconnues.
  - La _variability_ en architecture présente des difficultés :
    - **Elle rend le travail plus difficile** : les solutions qu’on imagine finissent par ne pas être les bonnes, les problèmes qu’on tacle finissent par en cacher d’autres, les décisions des autres équipes nous impactent d’une manière qu’on n’aurait pas pu prévoir etc.
    - **Elle se manifeste dans des endroits imprévisibles, et à des moments imprévisibles** : quel que soit le temps qu’on passe à planifier en envisager les possibilités, on va toujours se confronter à des imprévus, qu’ils soient techniques ou humains.
    - **Elle produit de la charge cognitive** : que ce soit de l’_instinsic_, de l’_extraneous_, ou de la _germaine_ (cf. **_Team Topologies_**). On doit en permanence penser à toutes les possibilités, et si ça vaut la peine de les adresser.
    - **Elle produit un besoin de communication et de synchronisation** : que ce soit entre membres d’une équipe, ou entre équipes, il faut faire des meetings pour être au clair sur les choses à adresser qu’on n’avait pas prévu.
  - Mais la **_variability_ est aussi l’élan vital du développement logiciel**.
    - L’auteur critique le lean, en mettant en avant que là où la _variability_ n’est pas souhaitable dans les usines, elle est cruciale dans le développement logiciel.
    - La _variability_ permet aux équipes produit de **délivrer tout ce qu’on peut imaginer très rapidement**. C’est parce qu’il y a de la _variability_ qu’on va explorer telle approche qui finit par échouer, mais qui nous mène à autre chose qui se révèle bien meilleur que ce qu’on avait au départ. Tout prévoir à l’avance empêchera d’arriver aux meilleures solutions.
    - En conséquence, l’auteur propose de gérer la _variability_ pour accueillir l’_émergence_, plutôt que de l’éviter absolument.
- On peut gérer la _variability_ en partant des **décisions d’architecture qui émergent d’un besoin d’implémenter une user story**.
  - Les user stories sont des slices atomiques de use-case, qu’on peut implémenter rapidement. L’auteur recommande à ce propos **_User Stories Applied for Agile Software Development_** de Mike Cohn, et **_User Story Mapping_** de Jeff Patton.
  - **1 - Prendre des décisions et les tester rapidement** : la seule manière de lever les inconnues c’est de se confronter à du feedback, avant ça on ne peut qu’espérer que ça marche.
  - **2 - Tester les décisions dans leur contexte fonctionnel** : ce qu’on veut savoir c’est si la décision d’architecture est bonne pour supporter notre use-case, et donc si le feedback utilisateur est celui qu’on attend.
  - **3 - Utiliser un _walking skeleton_ pour tester les décisions dans un nouveau système** : quand on crée un nouveau système où il n’y a pas de user stories sur lesquelles s’appuyer pour valider les décisions, le walking skeleton est une **implémentation de fonctionnalité minimale** permettant de tester le système.
    - On peut trouver des choses sur le walking skeleton notamment dans **_Growing Object-Oriented Software, Guided by Tests_** de Steve Freeman et Nat Pryce.
    - Le but est de trouver les problèmes d’architecture rapidement, plutôt qu’attendre d’avoir déjà fait beaucoup de développements et se rendre compte que le système ne tient pas certains des requirements.
  - **4 - Prendre de petites décisions** : des décisions portant sur un périmètre faible, où il y a peu de choses à considérer (ce qui ne veut pas dire que la décision ne sera pas significative). C’est un bon moyen de ne pas adresser un grand nombre d’inconnus en même temps.
    - Exemple de split de grande décision : dans la Story 2, la décision de l’architecte donne lieu à 3 décisions : refactorer le service, gérer l’aspect partage de code entre android et IOS, gérer le problème du stateful.
    - Les décisions avec un grand périmètre impliquent en général un grand nombre d’équipes, et leur enlèvent de l’autonomie. Par exemple : quel cloud provider utiliser pour l’ensemble de nos systèmes ?
    - Séparer une grande décision en plusieurs petites permet d’éviter qu’une inconnue dans le cadre de l’une des sous-branches impacte les autres, que ce soit d’un point de vue synchronisation, ou d’un point de vue implication des mêmes personnes. Et **la _variability_ de chaque petite décision sera levée plus rapidement**, grâce au feedback obtenu plus vite.
      - Reinertsen a fait des études statistiques et a trouvé que les petites tâches restent dans la backlog un temps d’un ordre de grandeur plus faible par rapport aux grandes tâches.
    - Contrairement à ce qu’on pourrait penser intuitivement, **mener à bien plusieurs petites décisions impliquent moins de travail qu’une grande** :
      - Les petites décisions font qu’il y a moins de personnes à aller consulter.
      - Les petites décisions font qu’il y a moins de choses à prendre en compte pour décider, donc on décide plus vite.
    - Les petites décisions **motivent les équipes à délivrer**. Si la décision est trop grande, implique trop d’inconnues, on n’en voit pas le bout. Mais si elle est petite, tout le monde a envie de l’implémenter rapidement.
    - **Une décision est limitée par son sous-aspect le plus faible**. Et donc plus la décision a un grand périmètre, plus elle risque d’être mauvaise globalement, là où si on la divise en petites décisions, seules certaines d’entre-elles seront affectées par l’aspect problématique.
    - **Comment diviser des décisions** d’architecture ?
      - **Écrire un ADR** suffit bien souvent à voir qu’il y a plusieurs décisions à séparer dans des ADRs différents. On peut s’en rendre compte de par le contexte, ou alors quand on se retrouve avec des options qui se séparent en groupes couvrant des variantes pour plusieurs problèmes.
      - Quand on a des choses rassemblées dans le même ADR parce qu’elles ont des similarités communes, on peut **vérifier quelles sont leurs différences**, et si on ne les a pas mises ensemble de manière illégitime.
      - On peut utiliser des critères particuliers pour **trouver où séparer les choses** :
        - _Functional fracture planes_ : on se pose la question “Que doit faire ce composant ?” pour différencier les composants qui ont un usage différent, malgré de la donnée apparemment similaire.
        - _Delivery-timing fracture planes_ : on se demande si certaines parties d’une décision peuvent être adressées plus tard parce que moins urgentes, dans une décision séparée.
        - _Codebase-location fracture planes_ : si une décision impacte les codebases de plusieurs équipes, on peut séparer en plusieurs décisions impactant les codebases d’une seule équipe.
        - _Unblocking flow of work fracture planes_ : on sépare la grande décision par une sous décision qui permet aux équipes de commencer à implémenter, suivie de plusieurs petites décisions pour chaque équipe.
          - La décision inter-équipe peut définir les contrats d’API avec des outils comme **Pact**.
        - _The “shared decision that unlocks everything else” fracture plane_ : on se demande “Quelles sont les décisions dont on a besoin pour débloquer cette décision ?”, pour trouver les sous décisions qui peuvent être implémentées d’abord, et qui débloquent la suite.
- Le flow de travail est facilité :
  - Des facteurs techniques et socio-techniques liés aux 5 révolutions et à l’advice process. Chacun d’autre eux permet de prendre de plus petites décisions, de livrer de plus petites itérations, le tout en parallèle.
  - Pour que ça marche, il faut que les décisions soient divisées autour des fracture planes des systèmes techniques et socio-techniques **de petite taille**, et que **ces systèmes soient eux-mêmes découplés**.
    - Avec l’advice process, ce découplage se fait en permanence par l’ensemble des acteurs. Ca peut être par exemple :
      - Bouger une fonctionnalité d’une équipe à une autre.
      - Refactorer des APIs pour cacher de l’information.
      - L’équipe arrive avec une nouvelle solution qu’elle imagine.
    - Un des mécanismes qui permet l’émergence de petites unités découplées est le fait que les acteurs vont chercher à créer de petites décisions, où le **nombre d’acteurs impliqués pour donner des advices est minimisé**.
- La _variability_ est **source de risque mais peut apporter de la valeur**. En adoptant une approche incrémentale des décisions d’architecture, on minimise le risque.
  - **Il vaut mieux livrer vite une mauvaise approche, que prendre beaucoup de temps pour livrer une bonne approche**.
    - Il est en fait impossible de savoir si notre approche est bonne tant qu’on n’a pas le feedback de la production et des clients. Donc livrer vite est la meilleure solution dans tous les cas, et si l’approche était mauvaise, on apprend et on la corrige.
    - Livrer vite a aussi l’avantage que l’équipe offre de la visibilité aux autres acteurs en montrant qu’elle avance et s’adapte, ce qui permet de laisser plus d’autonomie à l’équipe.
  - **Il faut surveiller les décisions qui prennent trop de temps**.
    - On peut faire ça dans un architecture advice forum : regarder les ADRs en cours qui sont depuis le plus longtemps, et essayer de comprendre ce qui bloque. Souvent c’est une décision qui a un périmètre trop grand.
  - S’il faut prioriser des décisions qui se gênent, on peut** prioriser celles qui apportent de la valeur**.
    - La valeur doit forcément passer par la mise en production, sinon on ne fait que spéculer.
    - Ça peut être de la valeur produit, ou de la valeur liée à l’apprentissage : tester quelque chose pour voir clarifier des développements futurs.

### 14 - Variability and the Interconnectedness of Decisions

- La _variability_ se manifeste sous plusieurs formes de problème rendant les décisions difficiles :
  - La **_variability_ technique** à propos du résultat incertain du choix de chaque option.
  - La **_variability_ sociale** liée aux biais du décideur et des advisors.
  - Le fait que les décisions en train d’être prises soient **interconnectées**, et qu’elles ont des conséquences l’une sur l’autre.
- Les **spikes** sont un outil issu de l’extreme programming, et centré sur les faits, permettant d’adresser la _variability_ technique et sociale en **complément des ADRs**.
  - Il s’agit de faire une expérimentation **timeboxée**, principalement sous forme de code, pour mieux comprendre le problème.
  - Les spikes ne permettent **pas de créer du code production, ni de prendre de décisions**. Ils permettent juste de récolter de l’information.
  - Les spikes sont un moyen d’obtenir de la _variability_ pas chère, en testant une solution **sans avoir à passer par le processus de décision** ni le fait d’écrire du code de production.
- Les spikes dans le processus de décision :
  - Ils peuvent être mis en place dès le moment qu’on voit qu’une décision a besoin d’être prise, ou pendant la rédaction d’un ADR.
  - Le spike s’écrit comme un ADR, et son contenu peut largement venir ensuite alimenter l’ADR qui suivra.
    - ** 1 - On remplit d’abord les éléments**.
      - **ID** : notre outil de gestion de tickets de backlog peut en attribuer un automatiquement.
      - **Title** : plutôt sous forme de question exprimant le problème. Par exemple : “Can we have shorter, human-readable inventory IDs?”
      - **Time box** : il faut fixer le temps passé dessus dès le départ, par exemple “une paire de devs pendant 3 jours”.
      - **Context** : on répond aux questions :
        - Qu’est-ce que va apporter de répondre à la question du spike ? Pourquoi maintenant ?
        - Qui est affecté ou intéressé par la réponse ?
        - Quelles sont les contraintes ?
      - **Options considered **: on liste les manières possibles de répondre au problème du spike.
      - **Consequences** : on les remplit au cours de l’exécution du spike.
    - **2. On exécute le spike**.
      - Ca va généralement être l’équipe initiatrice du spike, mais dans le cas d’une initiative individuelle (par exemple un architecte), ça peut aller dans la backlog de l’équipe concernée.
      - Au fil des expérimentations, on trouve de nouvelles options à essayer, et on remplit aussi la section _Consequences_ qui contient ce qui a été trouvé des expérimentations.
      - Un architecte hands on va typiquement vouloir faire des spikes avec les équipes qu’il assiste, pour lui aussi remettre les mains dans le code.
    - **3. On crée un ADR à partir du contenu du spike**.
      - Le titre doit être adapté.
      - Le contexte, les options et les conséquences peuvent être repris, et complétés.
      - On peut ensuite sélectionner une option, et passer en proposed.
