<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Effective Kafka – Reading notes</title><meta name="robots" content="index,follow"/><meta name="description" content="My detailed reading notes from computer science books"/><meta property="og:title" content="Effective Kafka – Reading notes"/><meta property="og:description" content="My detailed reading notes from computer science books"/><meta name="theme-color" content="#111" media="(prefers-color-scheme: dark)"/><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/><style>
        :root {
          --nextra-primary-hue: 212deg;
          --nextra-primary-saturation: 100%;
          --nextra-navbar-height: 4rem;
          --nextra-menu-height: 3.75rem;
          --nextra-banner-height: 2.5rem;
        }
        
        .dark {
          --nextra-primary-hue: 204deg;
          --nextra-primary-saturation: 100%;
        }
      </style><meta name="msapplication-TileColor" content="#fff"/><meta http-equiv="Content-Language" content="en"/><meta name="description" content="My detailed reading notes from computer science books"/><meta property="og:title" content="Reading notes"/><meta property="og:description" content="My detailed reading notes from computer science books"/><meta name="apple-mobile-web-app-title" content="Reading notes"/><link rel="icon" type="image/x-icon" href="/reading-notes/favicon.ico"/><meta name="next-head-count" content="16"/><link rel="preload" href="/reading-notes/_next/static/css/e0ae992ef9be83da.css" as="style" crossorigin=""/><link rel="stylesheet" href="/reading-notes/_next/static/css/e0ae992ef9be83da.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/reading-notes/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/reading-notes/_next/static/chunks/webpack-94b934e1f7075309.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/chunks/main-456465bb171feab1.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/chunks/pages/_app-63a309e84f977e9c.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/chunks/673-c9f6925171f8c938.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/chunks/pages/books/effective-kafka-28f840a5d8f0e148.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/vxJYrrk_6viBDsRgUryN3/_buildManifest.js" defer="" crossorigin=""></script><script src="/reading-notes/_next/static/vxJYrrk_6viBDsRgUryN3/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div dir="ltr"><script>document.documentElement.setAttribute('dir','ltr')</script><div class="nextra-nav-container nx-sticky nx-top-0 nx-z-20 nx-w-full nx-bg-transparent print:nx-hidden"><div class="nextra-nav-container-blur nx-pointer-events-none nx-absolute nx-z-[-1] nx-h-full nx-w-full nx-bg-white dark:nx-bg-dark nx-shadow-[0_2px_4px_rgba(0,0,0,.02),0_1px_0_rgba(0,0,0,.06)] dark:nx-shadow-[0_-1px_0_rgba(255,255,255,.1)_inset] contrast-more:nx-shadow-[0_0_0_1px_#000] contrast-more:dark:nx-shadow-[0_0_0_1px_#fff]"></div><nav class="nx-mx-auto nx-flex nx-h-[var(--nextra-navbar-height)] nx-max-w-[90rem] nx-items-center nx-justify-end nx-gap-2 nx-pl-[max(env(safe-area-inset-left),1.5rem)] nx-pr-[max(env(safe-area-inset-right),1.5rem)]"><a class="nx-flex nx-items-center hover:nx-opacity-75 ltr:nx-mr-auto rtl:nx-ml-auto" href="/reading-notes/"><img alt="Reading notes homepage" loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/reading-notes/logo.png"/></a><div class="nextra-search nx-relative md:nx-w-64 nx-hidden md:nx-inline-block mx-min-w-[200px]"><div class="nx-relative nx-flex nx-items-center nx-text-gray-900 contrast-more:nx-text-gray-800 dark:nx-text-gray-300 contrast-more:dark:nx-text-gray-300"><input spellcheck="false" class="nx-block nx-w-full nx-appearance-none nx-rounded-lg nx-px-3 nx-py-2 nx-transition-colors nx-text-base nx-leading-tight md:nx-text-sm nx-bg-black/[.05] dark:nx-bg-gray-50/10 focus:nx-bg-white dark:focus:nx-bg-dark placeholder:nx-text-gray-500 dark:placeholder:nx-text-gray-400 contrast-more:nx-border contrast-more:nx-border-current" type="search" placeholder="Search documentation…" value=""/></div></div><a href="https://github.com/mkrtchian/reading-notes" target="_blank" rel="noreferrer" class="nx-p-2 nx-text-current"><svg width="24" height="24" fill="currentColor" viewBox="3 3 18 18"><title>GitHub</title><path d="M12 3C7.0275 3 3 7.12937 3 12.2276C3 16.3109 5.57625 19.7597 9.15374 20.9824C9.60374 21.0631 9.77249 20.7863 9.77249 20.5441C9.77249 20.3249 9.76125 19.5982 9.76125 18.8254C7.5 19.2522 6.915 18.2602 6.735 17.7412C6.63375 17.4759 6.19499 16.6569 5.8125 16.4378C5.4975 16.2647 5.0475 15.838 5.80124 15.8264C6.51 15.8149 7.01625 16.4954 7.18499 16.7723C7.99499 18.1679 9.28875 17.7758 9.80625 17.5335C9.885 16.9337 10.1212 16.53 10.38 16.2993C8.3775 16.0687 6.285 15.2728 6.285 11.7432C6.285 10.7397 6.63375 9.9092 7.20749 9.26326C7.1175 9.03257 6.8025 8.08674 7.2975 6.81794C7.2975 6.81794 8.05125 6.57571 9.77249 7.76377C10.4925 7.55615 11.2575 7.45234 12.0225 7.45234C12.7875 7.45234 13.5525 7.55615 14.2725 7.76377C15.9937 6.56418 16.7475 6.81794 16.7475 6.81794C17.2424 8.08674 16.9275 9.03257 16.8375 9.26326C17.4113 9.9092 17.76 10.7281 17.76 11.7432C17.76 15.2843 15.6563 16.0687 13.6537 16.2993C13.98 16.5877 14.2613 17.1414 14.2613 18.0065C14.2613 19.2407 14.25 20.2326 14.25 20.5441C14.25 20.7863 14.4188 21.0746 14.8688 20.9824C16.6554 20.364 18.2079 19.1866 19.3078 17.6162C20.4077 16.0457 20.9995 14.1611 21 12.2276C21 7.12937 16.9725 3 12 3Z"></path></svg><span class="nx-sr-only">GitHub</span><span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a><button type="button" aria-label="Menu" class="nextra-hamburger -nx-mr-2 nx-rounded nx-p-2 active:nx-bg-gray-400/20 md:nx-hidden"><svg fill="none" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" class=""><g><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16"></path></g><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12h16"></path><g><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 18h16"></path></g></svg></button></nav></div><div class="nx-mx-auto nx-flex nx-max-w-[90rem]"><div class="motion-reduce:nx-transition-none [transition:background-color_1.5s_ease] nx-bg-transparent"></div><aside class="nextra-sidebar-container nx-flex nx-flex-col md:nx-top-16 md:nx-shrink-0 motion-reduce:nx-transform-none nx-transform-gpu nx-transition-all nx-ease-in-out print:nx-hidden md:nx-w-64 md:nx-sticky md:nx-self-start max-md:[transform:translate3d(0,-100%,0)]"><div class="nx-px-4 nx-pt-4 md:nx-hidden"><div class="nextra-search nx-relative md:nx-w-64"><div class="nx-relative nx-flex nx-items-center nx-text-gray-900 contrast-more:nx-text-gray-800 dark:nx-text-gray-300 contrast-more:dark:nx-text-gray-300"><input spellcheck="false" class="nx-block nx-w-full nx-appearance-none nx-rounded-lg nx-px-3 nx-py-2 nx-transition-colors nx-text-base nx-leading-tight md:nx-text-sm nx-bg-black/[.05] dark:nx-bg-gray-50/10 focus:nx-bg-white dark:focus:nx-bg-dark placeholder:nx-text-gray-500 dark:placeholder:nx-text-gray-400 contrast-more:nx-border contrast-more:nx-border-current" type="search" placeholder="Search documentation…" value=""/></div></div></div><div class="nx-overflow-y-auto nx-overflow-x-hidden nx-p-4 nx-grow md:nx-h-[calc(100vh-var(--nextra-navbar-height)-var(--nextra-menu-height))] nextra-scrollbar"><div class="nx-transform-gpu nx-overflow-hidden nx-transition-all nx-ease-in-out motion-reduce:nx-transition-none"><div class="nx-transition-opacity nx-duration-500 nx-ease-in-out motion-reduce:nx-transition-none nx-opacity-100"><ul class="nx-flex nx-flex-col nx-gap-1 nextra-menu-desktop max-md:nx-hidden"><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/">Introduction</a></li><li class="open"><button class="nx-items-center nx-justify-between nx-gap-2 nx-text-left nx-w-full nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50">Reading notes<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="nx-h-[18px] nx-min-w-[18px] nx-rounded-sm nx-p-0.5 hover:nx-bg-gray-800/5 dark:hover:nx-bg-gray-100/5"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" class="nx-origin-center nx-transition-transform rtl:-nx-rotate-180 ltr:nx-rotate-90 rtl:nx-rotate-[-270deg]"></path></svg></button><div class="nx-transform-gpu nx-overflow-hidden nx-transition-all nx-ease-in-out motion-reduce:nx-transition-none"><div class="nx-transition-opacity nx-duration-500 nx-ease-in-out motion-reduce:nx-transition-none nx-opacity-100 ltr:nx-pr-0 rtl:nx-pl-0 nx-pt-1"><ul class="nx-flex nx-flex-col nx-gap-1 nx-relative before:nx-absolute before:nx-inset-y-1 before:nx-w-px before:nx-bg-gray-200 before:nx-content-[&quot;&quot;] dark:before:nx-bg-neutral-800 ltr:nx-pl-3 ltr:before:nx-left-0 rtl:nx-pr-3 rtl:before:nx-right-0 ltr:nx-ml-3 rtl:nx-mr-3"><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/accelerate/">Accelerate</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/continuous-discovery-habits/">Continuous Discovery Habits</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/designing-cloud-data-platforms/">Designing Cloud Data Platforms</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/designing-data-intensive-applications/">Designing Data-Intensive Applications</a></li><li class="nx-flex nx-flex-col nx-gap-1 active"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-bg-primary-100 nx-font-semibold nx-text-primary-800 dark:nx-bg-primary-400/10 dark:nx-text-primary-600 contrast-more:nx-border-primary-500 contrast-more:dark:nx-border-primary-500" href="/reading-notes/books/effective-kafka/">Effective Kafka</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/effective-typescript/">Effective TypeScript</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/get-your-hands-dirty-on-clean-architecture/">Get Your Hands Dirty on Clean Architecture</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/learning-domain-driven-design/">Learning Domain-Driven Design</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/learning-to-scale/">Learning to Scale</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/monolith-to-microservices/">Monolith to Microservices</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/no-rules-rules/">No Rules Rules</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/outcomes-over-output/">Outcomes Over Output</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/refactoring/">Refactoring: Improving the Design of Existing Code</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/reinventing-organizations/">Reinventing Organizations</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/team-topologies/">Team Topologies</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/test-driven-development-by-example/">Test-Driven Development: By Example</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/the-design-of-web-apis/">The Design of Web APIs</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/the-five-dysfunctions-of-a-team/">The Five Dysfunctions of a Team</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/turn-the-ship-around/">Turn the Ship Around!</a></li><li class="nx-flex nx-flex-col nx-gap-1"><a class="nx-flex nx-rounded nx-px-2 nx-py-1.5 nx-text-sm nx-transition-colors [word-break:break-word] nx-cursor-pointer [-webkit-tap-highlight-color:transparent] [-webkit-touch-callout:none] contrast-more:nx-border nx-text-gray-500 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:nx-text-neutral-400 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50 contrast-more:nx-text-gray-900 contrast-more:dark:nx-text-gray-50 contrast-more:nx-border-transparent contrast-more:hover:nx-border-gray-900 contrast-more:dark:hover:nx-border-gray-50" href="/reading-notes/books/unit-testing/">Unit Testing: Principles, Practices, and Patterns</a></li></ul></div></div></li></ul></div></div></div><div class="nx-sticky nx-bottom-0 nx-bg-white dark:nx-bg-dark nx-mx-4 nx-py-4 nx-shadow-[0_-12px_16px_#fff] nx-flex nx-items-center nx-gap-2 dark:nx-border-neutral-800 dark:nx-shadow-[0_-12px_16px_#111] contrast-more:nx-border-neutral-400 contrast-more:nx-shadow-none contrast-more:dark:nx-shadow-none nx-border-t" data-toggle-animation="off"><div class="nx-grow nx-flex nx-flex-col"><button title="Change theme" class="nx-h-7 nx-rounded-md nx-px-2 nx-text-left nx-text-xs nx-font-medium nx-text-gray-600 nx-transition-colors dark:nx-text-gray-400 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50" id="headlessui-listbox-button-:Rlsr6:" type="button" aria-haspopup="listbox" aria-expanded="false" data-headlessui-state=""><div class="nx-flex nx-items-center nx-gap-2 nx-capitalize"><svg fill="none" viewBox="3 3 18 18" width="12" height="12" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" fill="currentColor" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg><span class="">Light</span></div></button></div></div></aside><nav class="nextra-toc nx-order-last nx-hidden nx-w-64 nx-shrink-0 xl:nx-block print:nx-hidden nx-px-4" aria-label="table of contents"><div class="nextra-scrollbar nx-sticky nx-top-16 nx-overflow-y-auto nx-pr-4 nx-pt-6 nx-text-sm [hyphens:auto] nx-max-h-[calc(100vh-var(--nextra-navbar-height)-env(safe-area-inset-bottom))] ltr:-nx-mr-4 rtl:-nx-ml-4"><p class="nx-mb-4 nx-font-semibold nx-tracking-tight">On This Page</p><ul><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#1---event-streaming-fundamentals" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">1 - Event Streaming Fundamentals</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#2---introducing-apache-kafka" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">2 - Introducing Apache Kafka</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#3---architecture-and-core-concepts" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">3 - Architecture and Core Concepts</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#4---installation" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">4 - Installation</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#5---getting-started" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">5 - Getting Started</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#6---design-considerations" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">6 - Design Considerations</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#7---serialization" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">7 - Serialization</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#8---bootstrapping-and-advertised-listeners" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">8 - Bootstrapping and Advertised Listeners</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#9---broker-configuration" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">9 - Broker Configuration</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#10---client-configuration" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">10 - Client Configuration</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#11---robust-configuration" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">11 - Robust Configuration</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#12---batching-and-compression" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">12 - Batching and Compression</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#13---replication-and-acknowledgements" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">13 - Replication and Acknowledgements</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#14---data-retention" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">14 - Data Retention</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#15---group-membership-and-partition-assignment" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">15 - Group Membership and Partition Assignment</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#16---security" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">16 - Security</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#17---quotas" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">17 - Quotas</a></li><li class="nx-my-2 nx-scroll-my-6 nx-scroll-py-6"><a href="#18---transactions" class="nx-font-semibold nx-inline-block nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-300 contrast-more:nx-text-gray-900 contrast-more:nx-underline contrast-more:dark:nx-text-gray-50 nx-w-full nx-break-words">18 - Transactions</a></li></ul><div class="nx-mt-8 nx-border-t nx-bg-white nx-pt-8 nx-shadow-[0_-12px_16px_white] dark:nx-bg-dark dark:nx-shadow-[0_-12px_16px_#111] nx-sticky nx-bottom-0 nx-flex nx-flex-col nx-items-start nx-gap-2 nx-pb-8 dark:nx-border-neutral-800 contrast-more:nx-border-t contrast-more:nx-border-neutral-400 contrast-more:nx-shadow-none contrast-more:dark:nx-border-neutral-400"><a href="https://github.com/mkrtchian/reading-notes/issues/new?title=Feedback%20for%20%E2%80%9CEffective%20Kafka%E2%80%9D&amp;labels=feedback" target="_blank" rel="noreferrer" class="nx-text-xs nx-font-medium nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-100 contrast-more:nx-text-gray-800 contrast-more:dark:nx-text-gray-50">Question? Give me feedback →<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a><a class="nx-text-xs nx-font-medium nx-text-gray-500 hover:nx-text-gray-900 dark:nx-text-gray-400 dark:hover:nx-text-gray-100 contrast-more:nx-text-gray-800 contrast-more:dark:nx-text-gray-50" href="https://github.com/mkrtchian/reading-notes/blob/main/pages/books/effective-kafka.mdx">Edit this page</a></div></div></nav><div id="reach-skip-nav"></div><article class="nx-w-full nx-break-words nextra-content nx-flex nx-min-h-[calc(100vh-var(--nextra-navbar-height))] nx-min-w-0 nx-justify-center nx-pb-8 nx-pr-[calc(env(safe-area-inset-right)-1.5rem)]"><main class="nx-w-full nx-min-w-0 nx-max-w-6xl nx-px-6 nx-pt-4 md:nx-px-12"><div class="nextra-breadcrumb nx-mt-1.5 nx-flex nx-items-center nx-gap-1 nx-overflow-hidden nx-text-sm nx-text-gray-500 dark:nx-text-gray-400 contrast-more:nx-text-current"><div class="nx-whitespace-nowrap nx-transition-colors nx-min-w-[24px] nx-overflow-hidden nx-text-ellipsis" title="Reading notes">Reading notes</div><svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="nx-w-3.5 nx-shrink-0"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg><div class="nx-whitespace-nowrap nx-transition-colors nx-font-medium nx-text-gray-700 contrast-more:nx-font-bold contrast-more:nx-text-current dark:nx-text-gray-100 contrast-more:dark:nx-text-current" title="Effective Kafka">Effective Kafka</div></div><h1 class="nx-mt-2 nx-text-4xl nx-font-bold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100">Effective Kafka</h1>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">1 - Event Streaming Fundamentals<a href="#1---event-streaming-fundamentals" id="1---event-streaming-fundamentals" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les <strong>systèmes distribués</strong> sont plus complexes que les systèmes non distribués, ils déplacent une partie de la <strong>complexité du local vers le global</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La raison pour laquelle on les utilise c&#x27;est qu&#x27;ils permettent de décomposer le système en plus petits problèmes qu&#x27;on va pouvoir diviser entre plusieurs équipes.</li>
<li class="nx-my-2">La complexité globale peut être réduite par certaines techniques, par exemple les messages asynchrones.</li>
<li class="nx-my-2">On y trouve des échecs partiels, intermittents, ou même byzantins (les nœuds envoient des informations fausses).</li>
<li class="nx-my-2">Le problème le plus important est sans doute celui de la consistance.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;<strong>event-driven architecture</strong> (EDA) consiste à avoir des <em>emitters</em> envoyant des notifications d&#x27;event à des <em>consumers</em>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les emitters n&#x27;ont aucune connaissance des consumers. Et de même les consumers n&#x27;ont pas connaissance des emitters.</li>
<li class="nx-my-2">Les notifications d&#x27;event sont immutables, que ce soit côté emitter ou consumer.</li>
<li class="nx-my-2">L&#x27;EDA est la manière <strong>la plus découplée</strong> de faire communiquer des composants entre eux.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le seul couplage sera dans le contenu des messages qui transitent.</li>
<li class="nx-my-2">Imaginons un système d&#x27;e-commerce, avec une plateforme BI et un CRM. Il leur suffira de consommer les events d&#x27;achat et d&#x27;y réagir en toute indépendance.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Parmi les autres possibilités qu&#x27;on aurait pour l&#x27;exemple e-commerce :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut les mettre dans un monolith (non-modulaire), mais la complexité risque d&#x27;augmenter à mesure que le modèle global est enrichi.</li>
<li class="nx-my-2">On peut utiliser des patterns d&#x27;intégration : des messages synchrones envoyés par le composant e-commerce ou par les deux autres. Dans ce cas on se rapproche du distributed monolith parce que les composants ne seront pas indépendants.</li>
<li class="nx-my-2">On peut utiliser la <em>data decapsulation</em>, où les composants BI et CRM viennent lire la DB du composant e-commerce. Dans ce cas on se retrouve dans un mode “get rich quick scheme” qui mène toujours à des pleurs. Le couplage est maximal.</li>
</ul>
</li>
<li class="nx-my-2">Cet exemple montre que <strong>l&#x27;EDA scale de manière linéaire</strong>, alors qu&#x27;avec les approches plus couplées, la complexité explose quand on scale le nombre de composants.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;EDA est beaucoup <strong>plus résilient</strong> que les approches couplées : si un composant est en situation d&#x27;échec, il a peu de chances d&#x27;impacter d&#x27;autres composants.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on reprend l&#x27;exemple d&#x27;e-commerce :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas où le composant d&#x27;e-commerce est en situation d&#x27;échec, les autres composants vont continuer à pouvoir fonctionner, mais simplement ils ne recevront plus de nouveaux events.</li>
<li class="nx-my-2">Dans le cas où par exemple le CRM est en situation d&#x27;échec, les events continueront d&#x27;arriver, et il pourra toujours rattraper son retard dès qu&#x27;il est rétabli.</li>
<li class="nx-my-2">On peut aussi prévoir une mesure pour que si le message broker est en situation d&#x27;échec, l&#x27;émetteur puisse publier les events localement, pour les mettre dans le message broker plus tard.</li>
</ul>
</li>
<li class="nx-my-2">Dans un système couplé, un composant qui est en échec peut entraîner des <em>correlated failures</em> chez les autres qui en dépendent.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut aussi avoir des <em>congestive collapses</em> dans le cas où certains composants sont temporairement surchargés, et que les requêtes synchrones mènent à avoir des timeouts, puis à envoyer plus de requêtes.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;EDA a aussi des avantages en termes de <strong>consistance</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il favorise l&#x27;ownership d&#x27;un élément stateful par un composant unique, les autres composants recevant les notifications d&#x27;event ne pouvant pas modifier cet état.</li>
<li class="nx-my-2">En dehors du composant owner, les events sont rejouables <strong>dans le bon ordre</strong>, garantissant une <em>sequential consistency</em>.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;EDA n&#x27;est cependant pas adaptée dans certains cas.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Elle n&#x27;est <strong>pas adaptée aux interactions synchrones</strong>.</li>
<li class="nx-my-2">Par contre, dans les cas où on peut l&#x27;utiliser, elle permet des améliorations significatives des aspects non fonctionnels.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;<strong>event streaming</strong> est un moyen d&#x27;obtenir un stream <strong>durable</strong> et <strong>ordonné</strong> d&#x27;events <strong>immutables</strong>, délivrés aux consumers qui ont souscrit.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;event streaming n&#x27;est pas nécessaire pour implémenter l&#x27;EDA, qui peut d&#x27;ailleurs être implémenté dans un monolith (cf. outils comme React qui sont basés sur des events).</li>
<li class="nx-my-2">En revanche l&#x27;<strong>event streaming est pertinent</strong> comme choix face aux solutions concurrentes (comme les message queues) <strong>dans le cadre d&#x27;EDA distribuées</strong>, parce qu&#x27;il a été conçu pour ça.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;event streaming supporte nativement l&#x27;immutabilité des events.</li>
<li class="nx-my-2">Il supporte la garantie d&#x27;ordre des events.</li>
<li class="nx-my-2">Il supporte le fait d&#x27;avoir de multiples consumers.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">2 - Introducing Apache Kafka<a href="#2---introducing-apache-kafka" id="2---introducing-apache-kafka" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka est une plateforme d&#x27;event streaming, mais elle comprend aussi un écosystème entier qui permet l&#x27;implémentation d&#x27;EDAs.</li>
<li class="nx-my-2">L&#x27;event streaming est récent comparé aux formes traditionnelles de messaging (MQ-style).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il n&#x27;y a pas de standard, mais Kafka est le leader du domaine, et son fonctionnement sert de modèle pour les solutions concurrentes comme <em style="color:#3d85c6;font-weight:bold;font-style:normal">Azure Event Hubs</em> et <em style="color:#3d85c6;font-weight:bold;font-style:normal">Apache Pulsar</em>.</li>
</ul>
</li>
<li class="nx-my-2">Historiquement, Kafka a été open-sourcé en 2011 par LinkedIn, et confié à la fondation Apache.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il avait été conçu notamment pour gérer les events d&#x27;activité des utilisateurs.</li>
<li class="nx-my-2">En 2019, LinkedIn opérait 100 clusters Kafka, pour un total de 100 000 topics et 7 millions de partitions.</li>
<li class="nx-my-2">Aujourd&#x27;hui Kafka est utilisé par des géants de la tech, pour des usages comme le real-time analytics, la data ingestion, le log aggregation et le messaging pour l&#x27;EDA.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Uber par exemple l&#x27;utilise pour gérer au total plus de 1000 milliards d&#x27;events par jour.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Parmi les usages qui permettent l&#x27;EDA, Kafka supporte :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>Publish-subscribe</strong> : un emitter publie des events, et plusieurs consumers les consomment sans que ces noeuds se connaissent.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est notamment utilisé pour des microservices avec un faible couplage.</li>
</ul>
</li>
<li class="nx-my-2"><strong>Log aggregation</strong> : un ensemble de sources publient des events sous forme de log (soit applicatifs, soit d&#x27;infrastructure), qu&#x27;on va ensuite agréger au sein du même topic, pour le consommer dans une DB optimisée pour la lecture, comme <em style="color:#3d85c6;font-weight:bold;font-style:normal">Elasticsearch</em> ou <em style="color:#3d85c6;font-weight:bold;font-style:normal">HBase</em>.</li>
<li class="nx-my-2"><strong>Log shipping</strong> : il s&#x27;agit de streamer des logs depuis une DB master vers un topic où plusieurs DB followers vont consommer et se mettre à jour.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce pattern permet notamment d&#x27;implémenter l&#x27;event sourcing.</li>
</ul>
</li>
<li class="nx-my-2"><strong>SEDA pipelines</strong> : le Stage Event-Driven Architecture est l&#x27;implémentation d&#x27;une pipeline d&#x27;events, où on fait une opération à chaque étape, avant d&#x27;émettre un event modifié pour l&#x27;étape suivante.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est typiquement utilisé avec les data warehouses, data lakes, le reporting et autres outils de BI.</li>
<li class="nx-my-2">On peut voir le log aggregation comme une forme de SEDA.</li>
</ul>
</li>
<li class="nx-my-2"><strong>CEP</strong> : le Complex Event Processing consiste en un composant qui consomme des events de multiples sources, et en extrait l&#x27;information pertinente.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il a souvent besoin d&#x27;un stockage pour se rappeler les patterns déjà vus et y réagir.</li>
<li class="nx-my-2">Ça peut être par exemple pour le trading algorithmique, l&#x27;analyse des menaces de sécurité, l&#x27;analyse de fraude en temps réel etc.</li>
</ul>
</li>
<li class="nx-my-2"><strong>Event-sourced CQRS</strong> : Kafka se place entre la DB master et les DBs de projection, en permettant de les alimenter chacune au travers du concept de <em>consumer groups</em>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La différence avec le log shipping c&#x27;est que le log shipping opère plutôt à l&#x27;intérieur d&#x27;un subdomain, alors que le CQRS peut aussi opérer à travers les subdomains.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">3 - Architecture and Core Concepts<a href="#3---architecture-and-core-concepts" id="3---architecture-and-core-concepts" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka est composé de plusieurs types de noeuds :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>Broker nodes</strong> : ce sont les composants principaux de Kafka, ils s&#x27;occupent des opérations I/O et de la persistance.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ces nœuds sont des processus Java.</li>
<li class="nx-my-2">Chaque partition est sous la responsabilité d&#x27;un nœud master qui peut écrire dedans, les followers en ont une copie et peuvent être lus.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Un même nœud peut être master pour certaines partitions, et follower pour d&#x27;autres.</li>
<li class="nx-my-2">L&#x27;ownership peut passer à un autre nœud en cas de besoin (opération spéciale qui le nécessite ou échec du nœud qui était master de la partition).</li>
<li class="nx-my-2">Concernant l&#x27;attribution de l&#x27;ownership, ça se fait d&#x27;abord en élisant un des nœuds comme <em>cluster controller</em>, puis celui-ci assigne l&#x27;ownership des partitions au gré des besoins.</li>
</ul>
</li>
<li class="nx-my-2">Augmenter le nombre de nœuds brokers constitue un moyen de scaler Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut améliorer la <em>durability</em> en ayant plusieurs copies de chaque partition (jusqu&#x27;à autant que le nombre de nœuds).</li>
<li class="nx-my-2">On peut améliorer l&#x27;<em>availability</em> pour les données en lecture.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>Zookeeper nodes</strong> : Zookeeper est un projet open source distinct de Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ses nœuds sont chargés d&#x27;élire le broker qui sera le <em>cluster controller</em>, de garantir qu&#x27;il n&#x27;y en ait qu&#x27;un, et d&#x27;en réélire un s&#x27;il n&#x27;est plus opérationnel.</li>
<li class="nx-my-2">Ils fournissent aussi diverses métadonnées à propos du cluster, par exemple l&#x27;état des différents nœuds, des informations de quotas, les access control list etc.</li>
</ul>
</li>
<li class="nx-my-2"><strong>Producers</strong> : les applications clientes qui écrivent dans les topics.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Un producer communique avec Kafka via TCP, avec une connexion par broker node.</li>
</ul>
</li>
<li class="nx-my-2"><strong>Consumers</strong> : les applications clientes qui lisent des topics.</li>
</ul>
</li>
<li class="nx-my-2">Le fonctionnement de Kafka se base sur des notions d&#x27;ordering venant de la théorie des ensembles (<em>set theory</em>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le <strong>total ordering</strong> consiste à avoir un ensemble d&#x27;éléments dont une <strong>seule configuration est possible</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut l&#x27;illustrer avec un set de nombres entiers <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">{ 2, 4, 6 }</code>. Si on enlève l&#x27;élément 4, puis qu&#x27;on le remet, il ne pourra qu&#x27;être à la 2ème place, avant le 6 et après le 2.</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>partial ordering</strong> consiste à avoir un ensemble d&#x27;éléments ordonnés selon un critère spécifique, mais dont <strong>plusieurs configurations sont possibles</strong> pour satisfaire le critère.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par exemple, si on a des entiers qu&#x27;on veut ordonner de manière à ce que le diviseur d&#x27;un nombre soit toujours après ce nombre, et qu&#x27;on a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">[ 2, 3, 4, 6, 9, 8 ]</code>, on peut tout autant les organiser en <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">[ 3, 2, 6, 9, 4, 8 ]</code>.</li>
</ul>
</li>
<li class="nx-my-2">La notion de <strong>causal order</strong> indique qu&#x27;on respecte le fait que certains éléments ont une relation <em>happened-before</em> entre eux qui est respectée, quel que soit leur ordre d&#x27;arrivée à destination.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette notion vient de l&#x27;étude des systèmes distribués (et non de la théorie des ensembles).</li>
<li class="nx-my-2">Elle est une forme de partial ordering.</li>
<li class="nx-my-2">Elle est la conséquence du fait qu&#x27;il n&#x27;y ait pas d&#x27;horloge commune à l&#x27;ensemble des nœuds d&#x27;un système distribué, et que les events peuvent arriver dans le mauvais ordre.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les <strong>records</strong> sont l&#x27;unité principale de Kafka. Ils correspondent aux events.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ils sont composés :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">D&#x27;attributs assez classiques : la <em>value</em> qui peut être sous forme binaire, des <em>headers</em> pour donner des métadonnées, la <em>partition</em> associée au record, l&#x27;<em>offset</em> par rapport aux autres records de la partition, un <em>timestamp</em>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La combinaison <em>partition</em> + <em>offset</em> permet d&#x27;identifier un record de manière unique.</li>
<li class="nx-my-2">L&#x27;<em>offset</em> est une valeur entière qui ne peut qu&#x27;augmenter, même s&#x27;il peut y avoir des gaps entre deux offsets qui se suivent (cf. compaction chapitre 14).</li>
</ul>
</li>
<li class="nx-my-2">D&#x27;un champ binaire un peu plus inhabituel qui est la <em>key</em>, et qui est utilisée par Kafka pour associer les records avec une même partition.</li>
</ul>
</li>
<li class="nx-my-2">Kafka est largement utilisé pour traiter des events à l&#x27;intérieur d&#x27;un bounded context, tout comme les events entre bounded contexts.</li>
<li class="nx-my-2">Il est aussi de plus en plus utilisé en remplacement des brokers traditionnels (<em style="color:#3d85c6;font-weight:bold;font-style:normal">RabbitMQ</em>, <em style="color:#3d85c6;font-weight:bold;font-style:normal">ActiveMQ</em>, <em style="color:#3d85c6;font-weight:bold;font-style:normal">AWS SQS/SNS</em>, <em style="color:#3d85c6;font-weight:bold;font-style:normal">Google Cloud Pub/Sub</em> etc.). Dans ce cas, les records ne correspondent pas forcément à des events, et on n&#x27;est pas forcément dans de l&#x27;EDA.</li>
</ul>
</li>
<li class="nx-my-2">Les <strong>partitions</strong> sont l&#x27;unité de stream principale qui contient les records.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les records d&#x27;une même partition sont <em>totally ordered</em>.</li>
<li class="nx-my-2">Les records publiés dans une partition par un même producer seront donc aussi <em>causally ordered</em> (la précédence respectée).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En revanche, si plusieurs producers publient dans la même partition sans eux-mêmes se synchroniser entre eux, les records de chaque producer seront causally ordered pour un même producer, mais ne le seront pas entre les producers (ça dépendra de qui l&#x27;a emporté pour publier plus vite).</li>
<li class="nx-my-2">Publier dans plusieurs partitions ne règle pas ce problème : les records de chaque producer ne seront pas causally ordered. Si on veut un tel ordre, il faut un seul producer.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les <strong>topics</strong> sont des unités logiques qui regroupent des partitions.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Vu qu&#x27;il s&#x27;agit d&#x27;une union de partitions qui sont chacune <em>totally ordered</em>, les topics peuvent être considérés comme <em>partially ordered</em>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut donc écrire dans les records de plusieurs partitions en parallèle, et n&#x27;assurer que l&#x27;ordre des records dans chaque partition.</li>
</ul>
</li>
<li class="nx-my-2">On peut indiquer à la main la partition vers laquelle on veut publier un record, mais généralement on indique la key, qui sera hashée pour correspondre avec une partition donnée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas où on <strong>réduit le nombre de partitions</strong>, les messages peuvent être <strong>détruits</strong>.</li>
<li class="nx-my-2">Dans le cas où on <strong>augmente le nombre de partitions</strong>, on peut <strong>perdre l&#x27;ordre</strong> qu&#x27;on voulait conserver avec nos keys, puisque la fonction de hash redirigera vers une autre partition.</li>
<li class="nx-my-2">Même si on a un nombre de partitions supérieur au nombre de keys, il est possible que deux keys mènent vers la même partition.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La seule chose qui est garantie, c&#x27;est qu&#x27;avec la même key, et si le nombre de partitions ne change pas, l&#x27;ordre sera respecté.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Un consumer peut souscrire à un topic en tant que membre d&#x27;un <strong>consumer group</strong>, et bénéficier d&#x27;un mécanisme de <strong>load balancing</strong> avec d&#x27;autres consumers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le 1er consumer qui souscrit se voit assigner toutes les partitions. Quand un 2ème consumer souscrit au topic, il se voit assigner environ la moitié des partitions qui étaient assignées au 1er. et ainsi de suite.</li>
<li class="nx-my-2">Les consumers ne peuvent que lire les events sans impact sur eux.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Une des conséquences c&#x27;est qu&#x27;on peut en ajouter beaucoup sans stresser le cluster. Et c&#x27;est une des différences par rapport aux brokers classiques.</li>
<li class="nx-my-2">Ils maintiennent les offsets de là où ils en sont pour chacune des partitions qu&#x27;ils sont en train de lire.</li>
<li class="nx-my-2">Les consumers de différents consumer groups n&#x27;ont pas d&#x27;impact les uns sur les autres.</li>
</ul>
</li>
<li class="nx-my-2">Kafka s&#x27;assure qu&#x27;il n&#x27;y a <strong>qu&#x27;un consumer d&#x27;un même consumer group</strong> qui peut lire dans une <strong>même partition</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si un consumer ne lit plus de messages jusqu&#x27;à dépasser un timeout, Kafka assignera ses partitions à un autre consumer, considéré comme sain, du même groupe.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Pour que Kafka puisse réassigner une partition à un autre consumer en gardant le bon offset, ou redonner le bon offset à un consumer qui se reconnecte après s&#x27;être déconnecté, il faut que <strong>les consumers communiquent leurs offsets à Kafka</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On appelle ce processus <em>committing offsets</em>.</li>
<li class="nx-my-2">On peut avoir un contrôle sur le <strong>moment où on va faire ce commit</strong>, et donc agir sur la <strong>garantie de delivery</strong> des messages, c&#x27;est-à-dire le fait qu&#x27;ils soient intégralement traités.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut passer d&#x27;une stratégie <em>at-most-once</em> à une stratégie <em>at-least-once</em> en faisant le commit après l&#x27;exécution de la callback au lieu du moment où le message est pris par le consumer.</li>
<li class="nx-my-2">Par défaut, Kafka va faire un commit toutes les 5 secondes, sauf si un record est toujours en train d‘être exécuté, auquel cas il attendra la prochaine occasion 5 secondes plus tard.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut régler cette durée de 5 secondes à une autre valeur avec la configuration <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">auto.commit.interval.ms</code>.</li>
<li class="nx-my-2">Ça implique que si le record est exécuté, et que dans les quelques secondes après le cluster bascule la partition sur un autre consumer, on risque de ne pas avoir commité et de réexécuter la callback du record dans le nouveau consumer.</li>
<li class="nx-my-2">Si on veut avoir le contrôle sur le moment exact où on veut faire le commit, on peut désactiver le commit automatique (configuration <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">enable.auto.commit</code> à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">false</code>), et le faire à la main dans le consumer.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le commit peut se faire via un canal in-memory asynchrone pour ne pas bloquer le consumer, avec la possibilité de fournir une callback qui sera exécutée par Kafka quand le commit aura été pris en compte<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ou alors le consumer peut aussi utiliser un appel synchrone pour le commit.</li>
</ul>
</li>
<li class="nx-my-2">Un cas classique est de traiter les records avec une stratégie <em>at-least-once</em> par batch, qu&#x27;on appelle <em>poll-process loop</em> :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le consumer garde un buffer de records qu&#x27;il prefetch en arrière-plan.</li>
<li class="nx-my-2">Il traite les records un par un (ou parfois en parallèle avec un pool de threads si c&#x27;est OK d&#x27;un point de vue business).</li>
<li class="nx-my-2">Quand on arrive au dernier record, il fait le commit de l&#x27;offset.</li>
<li class="nx-my-2">Puis il prend le batch suivant et recommence.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Même si c&#x27;est moins courant, il est possible de souscrire un consumer <strong>sans qu&#x27;il soit membre d&#x27;un consumer group</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans ce cas, il ne bénéficiera pas des divers mécanismes associés aux consumer groups : load balancing, rebalancing en cas d&#x27;échec, détection de l&#x27;échec par inactivité, persistance de l&#x27;offset.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il devra indiquer les couples topic/partition auxquels il souscrit, et devra persister ses propres offsets lui-même dans un store.</li>
</ul>
</li>
<li class="nx-my-2">Il peut y avoir deux cas d&#x27;usages :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le besoin d&#x27;avoir vraiment le contrôle sur la manière de consommer les messages, en stockant soi-même son offset etc.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Mais ce cas d&#x27;usage est très rare, et difficile à implémenter correctement.</li>
</ul>
</li>
<li class="nx-my-2">Un consumer éphémère qui est là juste pour monitorer ou débugger un topic, sans avoir besoin de persister d&#x27;offsets.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est ce que fait par exemple l&#x27;outil Kafdrop qui permet de visualiser les messages présents dans les partitions via une interface web : à chaque fois il attache un consumer sans groupe.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">4 - Installation<a href="#4---installation" id="4---installation" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il y a 4 méthodes pour installer Kafka (et Zookeeper) :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En utilisant les images Docker.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on choisit une autre méthode que Docker, on aura juste besoin d&#x27;avoir d&#x27;avoir un JDK d&#x27;installé.</li>
<li class="nx-my-2">La méthode Kafka dans Docker est la plus immédiate pour avoir Kafka qui tourne, mais elle est aussi connue pour être difficile à configurer si on veut personnaliser.</li>
</ul>
</li>
<li class="nx-my-2">En utilisant un package manager (yum, apt, homebrew etc.)</li>
<li class="nx-my-2">En clonant le dépôt git et en installant depuis les sources.</li>
<li class="nx-my-2">En téléchargeant des binaires sur le site de Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il suffit de télécharger un tar.gz et de le désarchiver, pour obtenir les exécutables de Kafka qu&#x27;on peut lancer avec notre JDK.</li>
<li class="nx-my-2">Le livre part là-dessus.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">La configuration de Kafka peut se faire en changeant les fichiers de conf dans le dossier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut voir les configs prises en compte dans les logs, à chaque fois qu&#x27;on démarre Kafka.</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">5 - Getting Started<a href="#5---getting-started" id="5---getting-started" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On a du tooling livré avec Kafka sous forme de scripts shell pour le gérer en CLI.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut par exemple créer un topic puis y ajouter des records.</li>
<li class="nx-my-2">On peut changer des offsets pour un consumer group.</li>
<li class="nx-my-2">etc.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;auteur <strong>déconseille de laisser Kafka créer automatiquement les topics</strong> (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">auto.create.topics.enable</code> à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">true</code>) pour plusieurs raisons :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les valeurs par défaut de Kafka remontent à sa création, et n&#x27;ont pas forcément été pensés pour l&#x27;usage qu&#x27;il a en général aujourd&#x27;hui.</li>
<li class="nx-my-2">Quand on crée un topic, on devrait décider du nombre de partitions en fonction des critères de parallélisation. Donc un nombre par défaut ne va en général pas être satisfaisant.</li>
<li class="nx-my-2">La création de topic à la lecture est encore plus problématique, puisqu&#x27;on va avoir des lecteurs qui croient lire quelque chose et qui ne lisent rien.</li>
</ul>
</li>
<li class="nx-my-2">Le <em>lag</em> est la différence entre l&#x27;offset qui a été commité par un consumer sur une partition donnée et le <em>high water mark</em> de la partition (c&#x27;est-à-dire le dernier record dispo à la consommation).</li>
<li class="nx-my-2">La <strong>suppression d&#x27;un topic est asynchrone</strong>, c&#x27;est-à-dire qu&#x27;elle sera effectivement réalisée quelque part dans le futur par Kafka, après qu&#x27;on l&#x27;ait demandée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour nos <strong>tests d&#x27;intégration</strong>, il va donc falloir trouver des solutions :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Supprimer le consumer group, les offsets enregistrés, ou mettre les offsets au high water mark (tous les trois ont le même effet).</li>
<li class="nx-my-2">2 - Tronquer les partitions en avançant le <em>low water mark</em> (le record le plus ancien disponible à la consommation).</li>
<li class="nx-my-2">3 - Utiliser des noms de topics uniques, et les supprimer au fil de l&#x27;eau (si on ne les réutilise pas, le fait qu&#x27;ils soient supprimés de manière asynchrone ne pose problème).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette dernière option est celle recommandée par l&#x27;auteur.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Supprimer les offsets pour un consumer group et sur un topic donné, fait que la prochaine fois que ces consumers voudront consommer le topic, ils seront par défaut assignés au dernier record.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ou au premier en fonction de l&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">auto.offset.reset</code>.</li>
<li class="nx-my-2">Si on supprimer un consumer group, c&#x27;est comme si on supprimait ses offsets pour l&#x27;ensemble des topics où il avait consommé des records.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;essentiel des classes du client Java se résument à :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - L&#x27;interface <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Producer</code>, l&#x27;implémentation <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">KafkaProducer</code>, et la représentation du record <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ProducerRecord</code>.</li>
<li class="nx-my-2">2 - La même chose côté consumer : <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Consumer</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">KafkaConsumer</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ConsumerRecord</code>.</li>
<li class="nx-my-2">Et c&#x27;est à peu près la même chose pour les autres clients qui s&#x27;en inspirent.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">enable.idempotence</code> à la création du producer permet de garder des séquences pour les couples producer/partition, pour s&#x27;assurer qu&#x27;un record n&#x27;est pas publié deux fois ou dans le mauvais ordre, dans le cas où il y aurait un timeout pendant une publication.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur conseille de l&#x27;activer.</li>
</ul>
</li>
<li class="nx-my-2">Il faut bien penser à fermer la connexion, sinon on risque de monopoliser des ressources côté client et serveur.</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">6 - Design Considerations<a href="#6---design-considerations" id="6---design-considerations" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">A propos de la séparation des <strong>responsabilités</strong> entre producers et consumers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas d&#x27;un <strong>event-oriented broadcast</strong>, c&#x27;est le producer qui a la responsabilité de la configuration du topic et du format des données publiées.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est utile pour que les producers ne connaissent pas du tout les consumers, et qu&#x27;on reste sur du couplage faible.</li>
<li class="nx-my-2">Le fait qu&#x27;on puisse avoir plusieurs consumers aux intérêts différents montre qu&#x27;il est plus pertinent que le producer ait la responsabilité des messages.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour autant, on peut se demander comment faire en sorte que les consumers soient tous satisfaits par le modèle proposé par le producer.</li>
<li class="nx-my-2">On peut mettre en place du <strong>topic conditioning</strong>, c&#x27;est-à-dire compartimenter les problèmes liés à chaque consumer avec une architecture SEDA, contenant pour chaque consumer (ou groupe de consumers aux intérêts communs), un module de conditionnement publiant à son tour dans un topic pour le consumer visé.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette solution permet de séparer les responsabilités, et laisser le producer avec son modèle, et chaque consumer avec le sien.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Pour du <strong>peer-to-peer messaging</strong>, c&#x27;est au contraire le consumer qui a la responsabilité de la configuration du topic et du format de données.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le consumer envoie des commandes au producer, pour que celui-ci lui prépare des données qu&#x27;il mettra dans Kafka.</li>
</ul>
</li>
<li class="nx-my-2">Dans tous les cas, les flows doivent être designés avec soin, en prenant en compte les besoins des producers et des consumers.</li>
</ul>
</li>
<li class="nx-my-2">Concernant la question du <strong>parallélisme</strong> dans le cas où on veut laisser plusieurs consumers consommer depuis plusieurs partitions, il y a des facteurs à prendre en compte pour obtenir quelque chose de performant.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;organisation des partitions d&#x27;un topic est <strong>consumer-driven</strong>, du fait du design de Kafka. Le consumer se pose la question de la <strong>bonne clé de partitionnement</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En pratique, le consumer doit trouver une entité suffisamment stable pour que son identifiant puisse servir de clé de partitionnement.</li>
<li class="nx-my-2">Par exemple, si on a des tournois de football, avec des events représentant ce qui se passe dans le jeu, on peut prendre le match comme entité stable, et avoir tous les events d&#x27;un même match ordonnés dans une même partition.</li>
<li class="nx-my-2">Si on garde l&#x27;exemple mais qu&#x27;un consumer est intéressé par le déroulement du tournoi, alors il nous faudra garder l&#x27;ordre des matchs, et donc choisir comme entité stable le tournoi.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Mais on aura alors moins de possibilités de parallélisation puisqu&#x27;on ne pourra plus paralléliser les matchs.</li>
<li class="nx-my-2">L&#x27;autre possibilité c&#x27;est de laisser le consumer qui a besoin de l&#x27;ordre des tournois le reconstituer lui-même, avec des infos qu&#x27;il a dans les events.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Se pose ensuite la question du <strong>nombre de partitions du topic</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour rappel on ne peut pas enlever de partitions sans détruire de messages, et en rajouter fait que la fonction de hash n&#x27;envoie plus dans les mêmes partitions qu&#x27;avant le rajout (donc il vaut mieux éviter si on veut garder l&#x27;ordre des messages).</li>
<li class="nx-my-2">Une solution peut être d&#x27;avoir dès le début un <strong>nombre suffisamment élevé de partitions par topic</strong>, pour ne jamais avoir à les augmenter.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Attention cependant, trop de partitions peut causer des problèmes de performance.</li>
<li class="nx-my-2">Confluent recommande un nombre de partitions maximal par broker de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">100 x b x r</code> partitions (avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">b</code> le nombre de brokers du cluster, et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">r</code> le facteur de réplication).</li>
<li class="nx-my-2">Si on atteint le nombre maximal de partitions qu&#x27;on avait prévu, une technique peut être de créer un nouveau topic avec plus de partitions, et de copier l&#x27;ensemble des messages de l&#x27;ancien topic vers le nouveau. Ça nécessite un peu d&#x27;effort.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>nombre de consumers</strong> dans un consumer group doit être au moins aussi grand que le nombre de partitions si on veut profiter du maximum de parallélisme.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par contre, allouer un tel nombre peut aussi mener à du gâchis de ressources, vu que le broker ne fonctionne pas forcément en flux tendu.</li>
<li class="nx-my-2">On peut alors plutôt allouer un nombre variable de consumers au groupe, basé sur l&#x27;activité du cluster.</li>
</ul>
</li>
<li class="nx-my-2">Enfin on peut envisager d&#x27;avoir du <strong>parallélisme à l&#x27;intérieur des consumers</strong>, en gérant plusieurs threads, pour traiter plusieurs records en même temps.</li>
</ul>
</li>
<li class="nx-my-2">A propos de la question de la <strong>delivery des messages</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On parle ici de “delivery” au sens où les messages sont traités jusqu&#x27;au bout par les consumers, pas juste du fait qu&#x27;ils soient disponibles à la lecture (ça, ils le restent de toute façon pour tous les consumers dès lors que la publication a marché).</li>
<li class="nx-my-2">On peut avoir une delivery <strong>at-most-once</strong>, en faisant le commit dès le début de la lecture.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est utile dans les cas où la perte occasionnelle de donnée n&#x27;est pas grave, et ne laisse pas le système consommateur dans un état inconsistant de manière permanente.</li>
<li class="nx-my-2">Ca peut être aussi parce que faire l&#x27;action deux fois pose problème, alors le que le fait de la rater de temps en temps non.</li>
</ul>
</li>
<li class="nx-my-2">On peut avoir une delivery <strong>at-least-once</strong>, en ne faisant le commit qu&#x27;après exécution complète de la callback du consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est utile dans le cas où la perte de donnée n&#x27;est pas acceptable, et où on est prêt à recommencer certains messages pour l&#x27;éviter.</li>
<li class="nx-my-2">Par contre on doit être prêt à avoir la callback potentiellement exécutée plusieurs fois.</li>
</ul>
</li>
<li class="nx-my-2">Et enfin, si on veut une delivery <strong>exactly-once</strong>, on ne peut malheureusement pas compter sur le message broker à lui seul : on doit s&#x27;assurer d&#x27;avoir un flow <strong>idempotent</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On pourrait le vouloir pour avoir à la fois la consistance parce que la perte de donnée ou le fait de ne pas faire une action n&#x27;est pas acceptable, mais en même temps où le fait de le faire deux fois n&#x27;est pas acceptable non plus.</li>
<li class="nx-my-2">Pour réussir ça, on a besoin d&#x27;avoir une <strong>idempotence de bout en bout</strong>, c&#x27;est à dire que :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La callback du consumer ne doit faire que des changements idempotents. Par exemple un update en DB qui ne change pas l&#x27;état de la DB quand il est joué plusieurs fois.</li>
<li class="nx-my-2">Le consumer doit vérifier si les side-effects qu&#x27;il fait ont déjà été faits pour ne pas les refaire une 2ème fois. Par exemple, Kafka offre un mécanisme de transaction qui permet de ne publier qu&#x27;une fois dans un topic sortant pour un message d&#x27;un topic entrant.</li>
<li class="nx-my-2">Dans le cas où on ne peut pas savoir si le side-effect a déjà été fait ou pas, il faut que le side-effect lui-même soit rendu idempotent de bout en bout.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">7 - Serialization<a href="#7---serialization" id="7---serialization" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le client Java a des serializers de base et une interface à implémenter pour créer des serializers Kafka custom.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour l&#x27;auteur, même si cette approche est idiomatique, il vaut mieux avoir Kafka et tout ce qui y est lié isolé dans une couche de messaging pour que la logique business n&#x27;y soit pas liée et soit testable.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur préfère <strong>laisser la sérialisation côté logique business</strong>, et donc conseille de ne pas utiliser les serializers custom de Kafka dans ce cas.</li>
</ul>
</li>
<li class="nx-my-2">Et de la même manière, les choses spécifiques à Kafka comme le fait de mettre l&#x27;ID des customers comme clé, doivent être dans la couche de messaging pour pouvoir être mis en commun entre les use cases.</li>
</ul>
</li>
<li class="nx-my-2">Quand on est en mode <strong>commit manuel</strong>, on peut appeler la fonction qui fait le commit de manière asynchrone <strong>sans l&#x27;attendre</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça aura pour effet d&#x27;avoir plus d&#x27;offsets pas encore commités mais un throughput plus élevé.</li>
<li class="nx-my-2">On respecte quand même le <em>at-least-one delivery</em>.</li>
</ul>
</li>
<li class="nx-my-2">Dans le cas où on utilise le mécanisme de <em>poll-process loop</em> (où on consomme les messages par batch), le client Java va avoir deux threads : un pour aller chercher plus de records et un autre pour faire le processing des records qui sont déjà là.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il s&#x27;agit là d&#x27;un mécanisme de <strong>pipelining</strong>, où la 1ère étape va chercher de la donnée pour la mettre dans le buffer suivant jusqu&#x27;à ce que le buffer soit plein, auquel cas elle attend avant de continuer.</li>
<li class="nx-my-2">L&#x27;auteur propose une version encore plus parallélisée, en ajoutant une 3ème étape dans la pipeline pour séparer la désérialisation du reste du traitement du message.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;avantage c&#x27;est que ça peut augmenter le throughput, mais l&#x27;inconvénient c&#x27;est une utilisation plus intensive du CPU.</li>
<li class="nx-my-2">Il faut créer un thread à la main, et gérer la communication inter-thread à travers un buffer, avec tous les edge cases liés au parallélisme.</li>
<li class="nx-my-2">Selon l&#x27;auteur, cette technique a du sens parce que :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;utilisation de Kafka est souvent associée à des cas d&#x27;usages qui ont besoin de performance.</li>
<li class="nx-my-2">Elle ajoute de la complexité, mais qu&#x27;on n&#x27;a à faire qu&#x27;une fois et qu&#x27;on peut isoler dans un adapter qu&#x27;on réutilise.</li>
</ul>
</li>
<li class="nx-my-2">Côté publisher ça aurait moins de sens vu que la sérialisation est moins coûteuse que la désérialisation.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Il peut être pertinent de <strong>filtrer des messages au niveau de la couche adapter</strong> du consumer Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par exemple, si le topic contient plus de messages que ce que le use-case qui le consomme peut ou veut désérialiser.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça peut être parce que le producer publie les messages plusieurs fois, en indiquant la version du schéma dans le header, et qu&#x27;on ne veut en lire qu&#x27;une version sans avoir à parser les autres.</li>
<li class="nx-my-2">Ça peut aussi être un topic qui contient plusieurs types de messages, dont on ne veut traiter qu&#x27;un type.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">8 - Bootstrapping and Advertised Listeners<a href="#8---bootstrapping-and-advertised-listeners" id="8---bootstrapping-and-advertised-listeners" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Chaque partition a un leader broker, et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> follower brokers qui contiennent sa donnée (avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n + 1</code> étant le <strong>replication factor</strong>).</li>
<li class="nx-my-2">Pour pouvoir écrire un record, un client publisher doit l&#x27;envoyer au broker leader de la partition qui l&#x27;intéresse.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le leader transférera aux followers, mais on ne peut pas compter sur un des followers pour transférer d&#x27;abord au leader.</li>
<li class="nx-my-2">Ça veut donc dire que <strong>le client devra avoir une connexion directe</strong> avec quasi tous (ou même tous) les brokers, vu que tous les brokers peuvent être des leaders de partitions et qu&#x27;il risque de vouloir en lire plusieurs.</li>
<li class="nx-my-2">Les brokers sont au courant de la topologie du cluster parce qu&#x27;ils ont l&#x27;info partagée via ZooKeeper.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le client peut donc <strong>demander la liste des adresses IP des brokers à n&#x27;importe lequel d&#x27;entre eux</strong>. Et donc, pour peu qu&#x27;il ait au moins une adresse de broker valide, il peut réobtenir toutes les autres.</li>
<li class="nx-my-2">Le client est initialement fourni avec une <em>bootstrap list</em> des brokers, et ensuite se débrouille pour la mettre à jour en leur demandant.</li>
</ul>
</li>
<li class="nx-my-2">Cette technique de base de demander la liste des adresses à au moins un broker dont on a l&#x27;adresse valide n&#x27;est pas super fiable : si le client n&#x27;a plus aucune adresse valide parce qu&#x27;elles ont toutes changé, il est coincé.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce que fait la communauté pour répondre à cette problématique c&#x27;est d&#x27;utiliser des <strong>alias DNS, pointant vers les bonnes adresses IP des brokers</strong>.</li>
<li class="nx-my-2">La spécification DNS permet même d&#x27;indiquer un seul nom qui sera associé à une liste d&#x27;adresses IP pointant vers chacun des brokers.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Il y a un problème classique de configuration auquel beaucoup de monde se heurte, et qui empêche la connexion du client aux brokers : le client demande la liste des adresses, et le broker lui répond des adresses en <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">localhost</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La solution est de configurer les <strong>advertised listeners</strong> dans le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/server.properties</code>.</li>
<li class="nx-my-2">Les propriétés sont initialement commentées dans le fichier, et donc c&#x27;est les valeurs par défaut qui s&#x27;appliquent (on peut les retrouver dans la <a href="https://kafka.apache.org/documentation/#brokerconfigs" target="_blank" rel="noreferrer" class="nx-text-primary-600 nx-underline nx-decoration-from-font [text-underline-position:from-font]">documentation de Kafka<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>).</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">advertised.listeners</code> permet d&#x27;indiquer les URI qui seront envoyées aux clients qui demandent la liste des adresses des brokers. C&#x27;est ça qu&#x27;il faut configurer avec le bon hostname pour résoudre le problème de config.</li>
<li class="nx-my-2">Dans le cas où on a des clients situés dans des environnements réseau différents, on a besoin de leur advertiser des adresses différentes pour les mêmes brokers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est le cas par exemple si on a un VPC (virtual private cloud) avec le cluster Kafka et des clients, et d&#x27;autres clients situés à l&#x27;extérieur et ne pouvant pas accéder aux adresses IP internes au VPC.</li>
<li class="nx-my-2">Dans ce cas, on va pouvoir configurer plusieurs URI (ou plutôt sockets) sur lesquels écoute chaque broker (dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">listeners</code>), et plusieurs URI qui sont advertised (dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">advertised.listeners</code>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il faut faire attention à indiquer des ports différents pour chacune des URI si on ne veut pas de problèmes.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les problématiques de bootstrapping se posent largement dans les environnements conteneurisés. La simple utilisation de <strong>docker-compose</strong> nous amène à avoir l&#x27;équivalent d&#x27;un VPC interne aux containers lancés par docker-compose, et un mapping de port vers la machine hôte.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Exemple de config Kafka dans un <em>docker-compose</em> :<!-- -->
<div class="nextra-code-block nx-relative nx-mt-6 first:nx-mt-0"><pre class="nx-bg-primary-700/5 nx-mb-4 nx-overflow-x-auto nx-rounded-xl nx-subpixel-antialiased dark:nx-bg-primary-300/10 nx-text-[.9em] contrast-more:nx-border contrast-more:nx-border-primary-900/20 contrast-more:nx-contrast-150 contrast-more:dark:nx-border-primary-100/40 nx-py-4" data-language="yml" data-theme="default"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr" data-language="yml" data-theme="default"><span class="line"><span style="color:var(--shiki-token-keyword)">kafka</span><span style="color:var(--shiki-token-keyword)">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-keyword)">image</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string-expression)">bitnami/kafka:2</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-keyword)">ports</span><span style="color:var(--shiki-token-keyword)">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    - </span><span style="color:var(--shiki-token-string-expression)">9092:9092</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-keyword)">environment</span><span style="color:var(--shiki-token-keyword)">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string-expression)">zookeeper:2181</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">ALLOW_PLAINTEXT_LISTENER</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string-expression)">&quot;yes&quot;</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">KAFKA_LISTENERS</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-keyword)">&gt;-</span></span>
<span class="line"><span style="color:var(--shiki-token-string)">      INTERNAL://:29092,EXTERNAL://:9092</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">KAFKA_ADVERTISED_LISTENERS</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-keyword)">&gt;-</span></span>
<span class="line"><span style="color:var(--shiki-token-string)">      INTERNAL://kafka:29092,EXTERNAL://localhost:9092</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-keyword)">&gt;-</span></span>
<span class="line"><span style="color:var(--shiki-token-string)">      INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-keyword)">KAFKA_INTER_BROKER_LISTENER_NAME</span><span style="color:var(--shiki-token-keyword)">:</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string-expression)">&quot;INTERNAL&quot;</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-keyword)">depends_on</span><span style="color:var(--shiki-token-keyword)">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    - </span><span style="color:var(--shiki-token-string-expression)">zookeeper</span></span></code></pre><div class="nx-opacity-0 nx-transition [div:hover&gt;&amp;]:nx-opacity-100 focus-within:nx-opacity-100 nx-flex nx-gap-1 nx-absolute nx-m-[11px] nx-right-0 nx-top-0"><button class="nextra-button nx-transition-all active:nx-opacity-50 nx-bg-primary-700/5 nx-border nx-border-black/5 nx-text-gray-600 hover:nx-text-gray-900 nx-rounded-md nx-p-1.5 dark:nx-bg-primary-300/10 dark:nx-border-white/10 dark:nx-text-gray-400 dark:hover:nx-text-gray-50 md:nx-hidden" title="Toggle word wrap"><svg viewBox="0 0 24 24" width="24" height="24" class="nx-pointer-events-none nx-h-4 nx-w-4"><path fill="currentColor" d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button></div></div>
</li>
<li class="nx-my-2">On définit ici deux protocoles propres à Kafka (et associés au type <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">PLAINTEXT</code>, donc non sécurisés) : un qu&#x27;on appelle <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">INTERNAL</code> pour l&#x27;URI depuis le réseau interne des containers <em>docker-compose</em>, et un autre qu&#x27;on appelle <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">EXTERNAL</code> pour le réseau de l&#x27;hôte.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">KAFKA_LISTENERS</code> est l&#x27;équivalent de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">listeners</code> dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/server.properties</code>, c&#x27;est-à-dire les sockets sur lesquels le broker écoute.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On choisit deux ports différents qui permettent de différencier les connexions internes et externes, et on indique qu&#x27;on écoute sur toutes les interfaces possibles (en n&#x27;indiquant aucun hostname ni adresse IP).</li>
</ul>
</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">KAFKA_ADVERTISED_LISTENERS</code> est l&#x27;équivalent de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">advertised.listeners</code>, c&#x27;est-à-dire les adresses URI communiquées aux clients pour joindre le broker.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On indique bien le hostname <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">localhost</code> aux clients du réseau externe, et le hostname <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka</code> aux clients du réseau interne (le nom des containers sert aussi de hostname dans <em>docker-compose</em>).</li>
</ul>
</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">KAFKA_INTER_BROKER_LISTENER_NAME</code> permet d&#x27;indiquer quel protocole doit être utilisé pour la communication avec les autres brokers du cluster.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">depends_on</code> permet d&#x27;indiquer l&#x27;ordre dans lequel on start les containers dans <em>docker-compose</em>.</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">9 - Broker Configuration<a href="#9---broker-configuration" id="9---broker-configuration" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La configuration peut se faire sur 4 entités de Kafka : les <strong>brokers</strong>, les <strong>topics</strong>, les <strong>clients</strong> et les <strong>users</strong>.</li>
<li class="nx-my-2">Il existe une <strong>configuration statique</strong> et une <strong>configuration dynamique</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Historiquement la configuration dynamique a été introduite pour faciliter l&#x27;administration de gros clusters, et pour ne plus avoir besoin de restart.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La communauté a décidé qu&#x27;enlever la configuration statique était trop radical, donc elle a été gardée en fallback.</li>
</ul>
</li>
<li class="nx-my-2">La configuration statique se fait en changeant le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/server.properties</code> et en redémarrant le broker.</li>
<li class="nx-my-2">La configuration dynamique se fait via l&#x27;admin API de Kafka, au niveau du broker ou du cluster entier.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Elle est stockée dans Zookeeper, mais ne nécessite pas la communication directe avec Zookeeper pour faire des modifications de config.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Côté <strong>précédence</strong>, c&#x27;est d&#x27;abord la config dynamique par entité qui prend le pas, puis la config dynamique au niveau du cluster, et enfin la config statique.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si rien n&#x27;est défini, les valeurs par défaut s&#x27;appliquent.</li>
<li class="nx-my-2">Dans le cas de propriétés dépréciées et remplacées par d&#x27;autres, les propriétés dépréciées sont prises en compte si elles sont utilisées, et sinon c&#x27;est la valeur par défaut des nouvelles propriétés qui est prise en compte.</li>
</ul>
</li>
<li class="nx-my-2">Quelques infos sur les <strong>changements de config des brokers</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Sur la configuration <strong>statique</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Toutes les propriétés de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/server.properties</code> sont optionnelles, sauf <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">zookeeper.connect</code> qui contient la liste des adresses des nœuds ZooKeeper.</li>
<li class="nx-my-2">Il est considéré comme une <strong>bonne pratique</strong> de spécifier la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">broker.id</code> qui représente l&#x27;identifiant du broker. Si on ne le fait pas, ZooKeeper assignera un ID automatiquement à chaque broker (par défaut en commençant par <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1001</code>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour changer cette propriété, il faut :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">D&#x27;abord arrêter le broker.</li>
<li class="nx-my-2">Faire le changement dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">server.properties</code>.</li>
<li class="nx-my-2">Faire le changement dans le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">meta.properties</code> (qui se trouve dans le dossier de log du broker), ou même supprimer le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">meta.properties</code> qui sera régénéré.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le dossier de log contient des fichiers essentiels avec l&#x27;info des partitions et des records (rien à voir avec du logging, on parle des données de Kafka).</li>
<li class="nx-my-2">Son path est configurée avec l&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.dirs</code>, par défaut c&#x27;est <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/tmp/kafka-logs</code>.</li>
</ul>
</li>
<li class="nx-my-2">Redémarrer le broker.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Sur la configuration <strong>dynamique</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut changer la config via l&#x27;outil CLI fourni par Kafka sous forme de script bash : <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-configs.sh</code>, ou via une librairie cliente tierce qui va se connecter à Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par exemple pour afficher la liste des configurations dynamiques pour le broker 1001 sur un Kafka qui tourne localement :<!-- -->
<div class="nextra-code-block nx-relative nx-mt-6 first:nx-mt-0"><pre class="nx-bg-primary-700/5 nx-mb-4 nx-overflow-x-auto nx-rounded-xl nx-subpixel-antialiased dark:nx-bg-primary-300/10 nx-text-[.9em] contrast-more:nx-border contrast-more:nx-border-primary-900/20 contrast-more:nx-contrast-150 contrast-more:dark:nx-border-primary-100/40 nx-py-4" data-language="bash" data-theme="default"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr" data-language="bash" data-theme="default"><span class="line"><span style="color:var(--shiki-token-function)">./kafka-configs.sh</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-function)">--bootstrap-server</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string)">localhost:9092</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-function)">--entity-type</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-string)">brokers</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-function)">--entity-name</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-constant)">1001</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-function)">--describe</span></span></code></pre><div class="nx-opacity-0 nx-transition [div:hover&gt;&amp;]:nx-opacity-100 focus-within:nx-opacity-100 nx-flex nx-gap-1 nx-absolute nx-m-[11px] nx-right-0 nx-top-0"><button class="nextra-button nx-transition-all active:nx-opacity-50 nx-bg-primary-700/5 nx-border nx-border-black/5 nx-text-gray-600 hover:nx-text-gray-900 nx-rounded-md nx-p-1.5 dark:nx-bg-primary-300/10 dark:nx-border-white/10 dark:nx-text-gray-400 dark:hover:nx-text-gray-50 md:nx-hidden" title="Toggle word wrap"><svg viewBox="0 0 24 24" width="24" height="24" class="nx-pointer-events-none nx-h-4 nx-w-4"><path fill="currentColor" d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button></div></div>
</li>
</ul>
</li>
<li class="nx-my-2">Il faut faire attention avec les configurations dynamiques, on peut facilement mettre un cluster par terre si on fait une mauvaise manip.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Quand on modifie <strong>une config pour tout le cluster</strong>, c&#x27;est une bonne pratique de la modifier <strong>d&#x27;abord pour un broker</strong>, au cas où elle aurait un impact non souhaité qui serait du coup plus limité.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">A propos de la <strong>configuration des topics</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ils peuvent être configurés statiquement via <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/server.properties</code>, ou dynamiquement au niveau du cluster (une configuration de topic par broker n&#x27;aurait pas de sens).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut aussi modifier dynamiquement certaines propriétés par topic.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">10 - Client Configuration<a href="#10---client-configuration" id="10---client-configuration" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0">La configuration du client est beaucoup plus sensible, en partie parce qu&#x27;elle tombe <strong>sous la responsabilité des développeurs applicatifs</strong>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En général la configuration des brokers se fait par des personnes spécialistes de l&#x27;infra, gérant d&#x27;autres éléments d&#x27;infrastructure, et connaissant la manière de gérer les risques.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On voit aussi de plus un shift vers les versions de serveurs Kafka pré-configurées. Ça ne peut pas être le cas des clients.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>La plupart des problèmes</strong> avec Kafka viennent d&#x27;une <strong>mauvaise utilisation côté client</strong>, parce que les développeurs ne le connaissent pas assez bien.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Exemple : il est notoire que Kafka offre des garanties importantes pour ce qui est de la durabilité des records. Mais en réalité ça dépend des paramètres.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il y a déjà la question du stockage, elle-même influencée par le nombre de brokers.</li>
<li class="nx-my-2">Et ensuite il y a des configurations côté client :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le replication factor et quelques autres pour ce qui est de s&#x27;assurer que la donnée reste en cas de problème avec certaines machines.</li>
<li class="nx-my-2">Le nombre d&#x27;acknowledgements que le broker leader de la partition doit demander avant de considérer le record comme validé, et le fait d&#x27;attendre soi-même l&#x27;acknowledgement du leader avant de considérer le message comme publié.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les développeurs imaginent aussi que le comportement par défaut de Kafka optimise la garantie d&#x27;ordre et de delivery des records. Mais ces valeurs sont issues de l&#x27;utilisation initiale de Linkedin qui avait surtout besoin de performance dans son cas d&#x27;usage.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>La 1ère règle de l&#x27;optimisation avec Kafka est : ne le faites pas</strong>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La plupart du temps, les configurations qui offrent des garanties vis-à-vis des records n&#x27;ont pas un si grand impact que ça. On peut attendre d&#x27;en avoir vraiment besoin.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0">Pour ce qui est des <strong>configurations communes</strong> à tous les types de clients (producer, consumer, admin).</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>bootstrap.servers</strong> permet de contacter les brokers, mais ensuite le plus important c&#x27;est que les brokers envoient les bonnes adresses (cf. le chapitre précédent).</li>
<li class="nx-my-2"><strong>client.dns.lookup</strong> donne la possibilité d&#x27;utiliser des alias DNS liés à plusieurs adresses.</li>
<li class="nx-my-2"><strong>client.id</strong> permet de définir l&#x27;identifiant du client, comme on l&#x27;a fait pour le serveur dans le chapitre d&#x27;avant. Ça permet la traçabilité, et la gestion de quotas.</li>
<li class="nx-my-2"><strong>retries</strong> indique le nombre de fois qu&#x27;on va recommencer une opération qui se termine par une erreur transiente, c&#x27;est-à-dire qui peut potentiellement ne pas se reproduire en réessayant.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>retry.backoff.ms</strong> indique la durée d&#x27;attente avant de réessayer.</li>
<li class="nx-my-2">Par défaut on bourrine, en recommençant un nombre infini de fois toutes les 100 ms.</li>
<li class="nx-my-2">L&#x27;autre possibilité c&#x27;est en gros de limiter les retries, en ayant conscience que du coup on se retrouvera à un moment où un autre à avoir des opérations qui sont en erreur pour des raisons temporaires. Mais on n&#x27;aura pas bloqué pendant longtemps.</li>
</ul>
</li>
<li class="nx-my-2">Quand on veut utiliser Kafka dans des <strong>tests d&#x27;intégration</strong>, il faut prendre en compte que le fait de le lancer dans un environnement virtualisé type Docker va ralentir considérablement son démarrage.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le fait que Kafka écoute sur le port ne suffit pas pour qu&#x27;il soit prêt à accepter des requêtes. Il peut donc falloir attendre un certain temps au début des tests pour qu&#x27;il démarre.</li>
<li class="nx-my-2">Et c&#x27;est encore pire avec Docker sur MacOS.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0">Pour ce qui est de la <strong>configuration du producer</strong>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>acks</strong> permet d&#x27;indiquer le nombre d&#x27;acknowledgements qu&#x27;on veut attendre de la part du broker leader avant de considérer que le message est publié.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">0</code> indique qu&#x27;on ne veut pas attendre du tout.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1</code> indique qu&#x27;on veut attendre que le leader lui-même ait écrit le record dans son log à lui.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est la valeur par défaut si <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">enable.idempotence</code> est <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">false</code>.</li>
</ul>
</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">-1</code> permet d&#x27;indiquer qu&#x27;on veut attendre que le leader mais aussi tous les followers aient écrit le record dans leurs log.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est la valeur par défaut si <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">enable.idempotence</code> est <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">true</code>.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>max.in.flight.per.connection</strong> indique le nombre de records qu&#x27;on veut pouvoir publier (par défaut 5), avant d&#x27;avoir à attendre le nombre d&#x27;acknowledgements qu&#x27;on a indiqué dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks</code>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Augmenter ce nombre permet de se prémunir contre la lenteur du réseau, vu qu&#x27;attendre la confirmation à chaque fois qu&#x27;on veut publier nous empêche de publier vite.</li>
<li class="nx-my-2">Par contre, on risque de ne pas publier dans le bon ordre pour les records entre deux acknowledgements.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il suffit qu&#x27;un record A ait une erreur transiente qui est retentée puis réussie, mais que le record suivant B ait réussi immédiatement et avant le record A. Ce qui inverse l&#x27;ordre de publication de A et B.</li>
<li class="nx-my-2">Pour ne pas avoir le problème il faudrait soit avoir <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.in.flight.per.connection</code> à 1 (attendre la confirmation à chaque publication), soit <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">retries</code> à 0 (ne jamais réessayer les erreurs transientes).</li>
<li class="nx-my-2">En réalité il y a une 3ème option qui est d&#x27;activer <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">enable.idempotence</code>, où Kafka va utiliser un mécanisme qui remet le bon ordre pour les records qui arrivent avec le mauvais ordre.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>enable.idempotence</strong>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Permet de garantir que :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les records soient publiés <strong>au plus une fois</strong> (donc dédupliqués).</li>
<li class="nx-my-2">Les records sont publiés <strong>dans l&#x27;ordre indiqué par le client</strong> producer.</li>
<li class="nx-my-2">Les records sont d&#x27;abord persistés sur l&#x27;ensemble des réplicas avant d&#x27;envoyer l&#x27;acknowledgement.</li>
</ul>
</li>
<li class="nx-my-2">Il nécessite que (si ces propriétés ne sont pas renseignées, elles seront mises aux bonnes valeurs par défaut, mais il ne faut juste pas de conflit) :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.in.flight.per.connection</code> soit <strong>entre 0 et 5</strong>.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">retries</code> soit plus grand que 0.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks</code> soit à -1.</li>
</ul>
</li>
<li class="nx-my-2">Pour ce qui est du problème de duplication, il peut se produire dans le cas où le producer subit un timeout alors que le message a été pris en compte par le serveur, mais avant qu&#x27;il ne reçoive l&#x27;acknowledgement. Il va donc réessayer d&#x27;envoyer le message juste après, ce qui fera un doublon.</li>
<li class="nx-my-2">Le mécanisme passe par l&#x27;attribution à chaque message par le producer, d&#x27;un ID qui s&#x27;incrémente monotoniquement. Et le broker maintient le dernier ID traité pour chaque couple [ producer ID, partition où on publie le record ].<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si le record qui arrive est identifié comme étant déjà arrivé, il est ignoré comme duplicata.</li>
<li class="nx-my-2">Si le record qui arrive a un ID plus grand qu&#x27;un incrément de 1 par rapport au dernier message traité, alors le message est considéré comme étant dans le mauvais ordre, et le broker répond une erreur indiquant au producer qu&#x27;il faut le requeuer.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>compression.type</strong> permet d&#x27;indiquer l&#x27;algo de <strong>compression</strong> qui sera utilisé par le producer (détaillé dans le chapitre 12).</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Parmi les possibilités :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><em>none</em></li>
<li class="nx-my-2"><em>gzip</em></li>
<li class="nx-my-2"><em>snappy</em> (optimisé pour le throughput, au dépend de la compression)</li>
<li class="nx-my-2"><em>lz4</em> (optimisé aussi pour le throughput, surtout la décompression)</li>
<li class="nx-my-2"><em>zstd</em> (nouvel algo, qui est censé faire un bon ratio throughput / performance).</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>key.serializer</strong> et <strong>value.serializer</strong> servent à indiquer la sérialisation des clés et valeurs des records (cf. le chapitre 7).</p>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>partitioner.class</strong> permet d&#x27;indiquer une classe Java qui va définir une manière différente de la manière par défaut d&#x27;associer les records et les partitions.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La manière par défaut va, dans l&#x27;ordre :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Si la partition est indiquée explicitement dans la publication du record, elle sera utilisée.</li>
<li class="nx-my-2">2 - Sinon, si on a indiqué une clé, la clé sera hashée pour déterminer la partition.</li>
<li class="nx-my-2">3 - Sinon, si le batch courant a une partition qui lui est assignée, on utilise cette partition.</li>
<li class="nx-my-2">4 - Sinon, on assigne une partition au batch et on l&#x27;utilise.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le 3 et 4 ont été introduits dans Kafka plus récemment, et permettent, dans le cas où on n&#x27;a pas de préférence d&#x27;ordre liée à une clé, de <strong>n&#x27;impliquer qu&#x27;un broker pour les records d&#x27;un batch.</strong> Ça <strong>améliore les perfs par 2 ou 3</strong>, tout en assurant une distribution entre brokers quand on a un grand nombre de batchs.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le client Java a aussi deux autres classes disponibles :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">RoundRobinPartitioner</code> permet d&#x27;alterner entre les brokers, sans prendre en compte la clé.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">UniformStickyPartitioner</code> permet de garder les records d&#x27;un même batch pour une même partition, sans prendre en compte la clé.</li>
</ul>
</li>
<li class="nx-my-2">On peut aussi donner une classe perso, mais l&#x27;auteur conseille d&#x27;envisager aussi d&#x27;encoder notre ordre custom dans une clé.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>interceptor.classes</strong> permet de définir des classes Java qui vont faire quelque chose de particulier à l&#x27;envoi et à l&#x27;acknowledgement.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça peut être utile pour le côté “plugin” réutilisable, parce qu&#x27;on est sur de l&#x27;AOP (Aspect Oriented Programming).</li>
<li class="nx-my-2">On peut par exemple l&#x27;utiliser pour ajouter une couche qui fait du logging, du tracing, de l&#x27;analyse de message pour empêcher la fuite de données etc.</li>
<li class="nx-my-2">Attention par contre : les exceptions dans les interceptors ne sont pas propagées.</li>
<li class="nx-my-2">Globalement si on y met quelque chose, il vaut mieux que ce soit du code simple et non bloquant.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>max.block.ms</strong> permet d&#x27;indiquer un timeout au processus de publication (par défaut 60 secondes).</p>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>batch.size</strong> permet d&#x27;attendre d&#x27;avoir une certaine taille de messages (par défaut 16 KB) avant d&#x27;envoyer un batch de publication.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>linger.ms</strong> fait la même chose au niveau du temps (par défaut 0 ms) en ajoutant un temps minimal à attendre avant d&#x27;envoyer un autre batch.</li>
<li class="nx-my-2">L&#x27;intérêt est de faire moins de requêtes au serveur et donc d&#x27;augmenter le throughput.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>request.timeout</strong> permet d&#x27;indiquer un timeout vis-à-vis de la réponse du broker pour faire l&#x27;acknowledgement (par défaut 30 secondes), avant de réessayer ou d&#x27;indiquer la publication comme échouée.</p>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>delivery.timeout</strong> permet d&#x27;indiquer un temps global pour une requête de publication, qui englobe l&#x27;envoi, les retries, et la réponse du serveur.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par défaut, c&#x27;est 120 secondes.</li>
<li class="nx-my-2">Il doit être supérieur aux autres timeouts réunis.</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0"><strong>transaction.id</strong> et <strong>transaction.timeout.ms</strong> permettent de gérer le comportement des transactions (cf. le chapitre 18).</p>
</li>
</ul>
</li>
<li class="nx-my-2">
<p class="nx-mt-6 nx-leading-7 first:nx-mt-0">Pour ce qui est de la <strong>configuration du consumer</strong>.</p>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>key.serializer</strong> et <strong>value.serializer</strong> servent à indiquer la désérialisation des clés et valeurs des records (cf. le chapitre 7).</li>
<li class="nx-my-2"><strong>interceptor.classes</strong> permet de faire la même chose que côté consumer, en traitant les records par batch.</li>
<li class="nx-my-2">Une des choses les plus importantes à régler, c&#x27;est <strong>la taille de ce qu&#x27;on va aller chercher en une requête</strong>. Ça se configure en plusieurs propriétés.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Plus on prendra de données, et plus le throughput sera grand, mais moins on aura un bon délai de propagation de bout en bout d&#x27;un record.</li>
<li class="nx-my-2">La propriété <strong>timeout</strong> donnée à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Consumer.poll()</code> permet de limiter son temps d&#x27;exécution.</li>
<li class="nx-my-2"><strong>fetch.min.bytes</strong> (par défaut 1) permet de demander au broker d&#x27;attendre d&#x27;avoir au moins un minimum de données à envoyer avant de répondre.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En réalité, le broker doit quand même envoyer une requête même s&#x27;il n&#x27;a pas assez de données, dans le cas où il dépasse un timeout fixé par <strong>fetch.max.wait.ms</strong> (par défaut 500 ms).</li>
</ul>
</li>
<li class="nx-my-2"><strong>fetch.max.bytes</strong> (par défaut 50 MB) indique au broker à partir de quelle taille il doit arrêter d&#x27;ajouter des données.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Vu qu&#x27;un record à lui seul (et donc à fortiori un batch) peut de toute façon dépasser cette taille, la limite n&#x27;est qu&#x27;indicative.</li>
<li class="nx-my-2">La même propriété limite existe pour la taille des partitions : <strong>max.partition.fetch.bytes</strong> (par défaut 1 MB).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette propriété permet de limiter l&#x27;impact des partitions “gourmandes”, en laissant de la place aux partitions qui ont moins de données.</li>
</ul>
</li>
<li class="nx-my-2">Intéressant à savoir : les brokers ne font en général pas de traitement sur les batchs. <strong>Les batchs sont envoyés par les producers, stockés tels quels, et envoyés tels quels aux consumers</strong>. C&#x27;est un choix de design de Kafka pour garantir une grande performance.</li>
</ul>
</li>
<li class="nx-my-2"><strong>max.poll.records</strong> (par défaut 500) permet de limiter le nombre de records retournés par <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Consumer.poll()</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Contrairement aux autres propriétés, celle-ci n&#x27;impacte pas le broker. C&#x27;est le client qui reçoit le même nombre de records par batch, et il va lui-même limiter ceux qu&#x27;il rend disponible. Il bufferise les autres pour les rendre disponibles à l&#x27;appel suivant.</li>
<li class="nx-my-2">Elle est là pour éviter que le client n&#x27;ait à traiter trop de records, et ne puisse pas appeler à nouveau <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code> avant <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.poll.interval.ms</code>.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>group.id</strong> permet d&#x27;indiquer le groupe d&#x27;un consumer. Si on ne le fournit pas, il deviendra sans groupe, et ne pourra pas bénéficier des mécanismes de d&#x27;assignation automatique de partition, détection des échecs, ni faire de commits au serveur pour sauvegarder son offset.</li>
<li class="nx-my-2"><strong>group.instance.id</strong> consiste à indiquer un identifiant à un consumer, unique dans son groupe, rendant le consumer <em>static</em>. L&#x27;effet est que si le consumer n&#x27;est plus là, sa partition n&#x27;est pas réassignée, mais reste en attente de son retour.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est pour éviter les rebalancing trop fréquents dans un contextes de manque d&#x27;availability transient.</li>
<li class="nx-my-2">Pour en savoir plus : chapitre 15.</li>
</ul>
</li>
<li class="nx-my-2">La <strong>détection d&#x27;échecs</strong> est contrôlée par la combinaison de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">heartbeat.interval.ms</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">session.timeout.ms</code> et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.poll.interval.ms</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce sujet fait partie des sujets délicats, source de nombreux problèmes.</li>
<li class="nx-my-2"><strong>heartbeat.interval.ms</strong> (par défaut 3 secondes) contrôle la fréquence à laquelle le consumer envoie des heartbeats.</li>
<li class="nx-my-2">Le broker <em>coordinator</em> du groupe de son côté vérifie que le consumer n&#x27;envoie pas son prochain heartbeat après le délai de <strong>session.timeout.ms</strong> (par défaut 10 secondes). Sinon il l&#x27;expulse et réassigne ses partitions dans le groupe.</li>
<li class="nx-my-2"><strong>max.poll.interval.ms</strong> (par défaut 5 minutes) est le délai maximal pour qu&#x27;un consumer rappelle <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code>. S&#x27;il ne l&#x27;a pas fait, il va lui-même arrêter d&#x27;envoyer des heartbeats et demander à quitter le groupe.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si le consumer est statique, il arrête les heartbeats mais ne demande pas à quitter le groupe. Il sera évincé par le broker s&#x27;il dépasse la <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">session.timeout.interval</code> sans avoir réémis de heartbeats.</li>
<li class="nx-my-2">Le but de ce comportement est d&#x27;éviter les situations où plusieurs consumers traitent les mêmes messages.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>auto.reset.offset</strong> permet d&#x27;indiquer ce qui se passe quand un consumer n&#x27;a pas d&#x27;offsets pour la partition qu&#x27;il consomme.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les options sont : <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">earliest</code> pour partir du low water mark, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">latest</code> pour partir du high water mark, et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">none</code> pour renvoyer une exception.</li>
<li class="nx-my-2">Les offsets sont stockés par le <em>group coordinator</em> dans un topic nommé <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__consumer_offsets</code>. Ce topic a un temps de rétention comme n&#x27;importe quel topic (par défaut 7 jours).</li>
<li class="nx-my-2">L&#x27;offset peut ne pas exister si :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - C&#x27;est le début de la formation du groupe et que la partition n&#x27;a pas encore été lue par lui.</li>
<li class="nx-my-2">2 - Quand rien n&#x27;a été consommé sur cette partition par le groupe (et donc aucun offset n&#x27;a été commité dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__consumer_offsets</code>) depuis plus longtemps que le délai de rétention de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__consumer_offsets</code>.</li>
<li class="nx-my-2">3 - Quand on a un offset qui pointe vers un record qui est dans un topic où le délai de rétention est plus faible, et a été dépassé. Donc l&#x27;offset pointe vers le vide.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>enable.auto.commit</strong> permet d&#x27;indiquer si le commit automatique est activé pour un consumer. Il s&#x27;agit d&#x27;envoyer un commit jusqu&#x27;au dernier record traité par le dernier l&#x27;appel à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code>, pour mettre à jour son offset.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par défaut le client commit toutes les 5 secondes (temps réglable avec <strong>auto.commit.interval.ms</strong>).</li>
<li class="nx-my-2">Si ça marchait vraiment comme ça (tel que le dit la doc), le client mettrait à jour son offset au dernier record reçu dans le batch envoyé par le dernier appel à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code>, alors même qu&#x27;il n&#x27;a pas forcément terminé de traiter le batch.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En réalité, l&#x27;implémentation règle le problème en envoyant le commit dans le même thread que celui qui traite les records, et seulement après que le batch ait été traité.</li>
<li class="nx-my-2">Mais ce comportement n&#x27;est pas garanti vu que la doc ne dit pas ça, Kafka pourrait à tout moment mettre à jour le comportement pour faire le commit dans un autre thread toutes les 5 secondes.</li>
<li class="nx-my-2">Pour éviter les problèmes, l&#x27;auteur conseille de <strong>faire le commit à la main</strong>.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>isolation.level</strong> permet d&#x27;indiquer le type de comportement d&#x27;une transaction vis-à-vis du consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_uncommitted</code> va renvoyer tous les records sans prendre en compte les transactions.</li>
<li class="nx-my-2">La valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_committed</code> va renvoyer les records qui ne font pas partie des transactions, et ceux qui font partie de transactions validées, mais pas ceux qui font partie de transactions qui ne sont pas encore validées.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour garantir l&#x27;ordre, tous les records qui doivent se trouver après les records qui sont dans des transactions non validées, seront aussi bloqués le temps de la transaction.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">11 - Robust Configuration<a href="#11---robust-configuration" id="11---robust-configuration" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka fait le choix d&#x27;émettre un warning dans le cas où on donne un mauvais nom de propriété de configuration.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour éviter les typos, on peut utiliser les constantes pour donner les valeurs.</li>
<li class="nx-my-2">NDLR : en TypeScript les clients sont typés.</li>
</ul>
</li>
<li class="nx-my-2">Si la propriété vient d&#x27;un fichier de config qui n&#x27;est pas du code, il n&#x27;y aura pas de check à la compilation.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans ce cas, il nous faut vérifier le contenu au runtime.</li>
<li class="nx-my-2">L&#x27;auteur propose de faire une classe de validation, qui propose des méthodes de type fluent chaining.<!-- -->
<div class="nextra-code-block nx-relative nx-mt-6 first:nx-mt-0"><pre class="nx-bg-primary-700/5 nx-mb-4 nx-overflow-x-auto nx-rounded-xl nx-subpixel-antialiased dark:nx-bg-primary-300/10 nx-text-[.9em] contrast-more:nx-border contrast-more:nx-border-primary-900/20 contrast-more:nx-contrast-150 contrast-more:dark:nx-border-primary-100/40 nx-py-4" data-language="java" data-theme="default"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr" data-language="java" data-theme="default"><span class="line"><span style="color:var(--shiki-token-keyword)">final</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-keyword)">var</span><span style="color:var(--shiki-color-text)"> config </span><span style="color:var(--shiki-token-keyword)">=</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-keyword)">new</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-function)">TypesafeProducerConfig()</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-function)">withBootstrapServers</span><span style="color:var(--shiki-color-text)">(</span><span style="color:var(--shiki-token-string-expression)">&quot;localhost:9092&quot;</span><span style="color:var(--shiki-color-text)">)</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-function)">withKeySerializerClass</span><span style="color:var(--shiki-color-text)">(</span><span style="color:var(--shiki-token-constant)">StringSerializer</span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-constant)">class</span><span style="color:var(--shiki-color-text)">)</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-function)">withValueSerializerClass</span><span style="color:var(--shiki-color-text)">(</span><span style="color:var(--shiki-token-constant)">StringSerializer</span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-constant)">class</span><span style="color:var(--shiki-color-text)">)</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  </span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-function)">withCustomEntry</span><span style="color:var(--shiki-color-text)">(</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">    </span><span style="color:var(--shiki-token-constant)">ProducerConfig</span><span style="color:var(--shiki-token-punctuation)">.</span><span style="color:var(--shiki-token-constant)">MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION</span><span style="color:var(--shiki-token-punctuation)">,</span><span style="color:var(--shiki-color-text)"> </span><span style="color:var(--shiki-token-constant)">1</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">  );</span></span></code></pre><div class="nx-opacity-0 nx-transition [div:hover&gt;&amp;]:nx-opacity-100 focus-within:nx-opacity-100 nx-flex nx-gap-1 nx-absolute nx-m-[11px] nx-right-0 nx-top-0"><button class="nextra-button nx-transition-all active:nx-opacity-50 nx-bg-primary-700/5 nx-border nx-border-black/5 nx-text-gray-600 hover:nx-text-gray-900 nx-rounded-md nx-p-1.5 dark:nx-bg-primary-300/10 dark:nx-border-white/10 dark:nx-text-gray-400 dark:hover:nx-text-gray-50 md:nx-hidden" title="Toggle word wrap"><svg viewBox="0 0 24 24" width="24" height="24" class="nx-pointer-events-none nx-h-4 nx-w-4"><path fill="currentColor" d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button></div></div>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">12 - Batching and Compression<a href="#12---batching-and-compression" id="12---batching-and-compression" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les batchs sont traités par Kafka comme un <strong>processus de bout en bout</strong> : le producer envoie les records par batchs, ils sont stockés comme tels, puis envoyés au consumer sous le même format.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ca permet de recourir à la <em>zero-copy optimization</em>, où les données sont copiées depuis le réseau vers le disque, puis à nouveau vers le réseau, sans que le CPU n&#x27;ai eu à intervenir pour transformer la donnée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas où TLS serait activé, la zero-copy optimization ne serait plus vraiment possible puisqu&#x27;il faudrait au moins déchiffrer ce qu&#x27;envoie le producer et chiffrer ensuite pour envoyer au consumer, ce qui utilise du CPU proportionnellement à la donnée.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Ce processus de création de batchs arrive quand il y a beaucoup de records à traiter successivement : Kafka va batcher les records qui sont <strong>en attente d&#x27;être envoyés</strong> (en limitant la taille des batchs à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">batch.size</code>). Quand le client veut publier au compte goutte, il ne fait pas de batchs.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">linger.ms</code> peut permettre d&#x27;avoir plus souvent des batchs : pendant ce temps qu&#x27;on attend, des records peuvent s&#x27;accumuler pour être batchés.</li>
<li class="nx-my-2">Kafka compte beaucoup sur <strong>du fine tuning fait par des admins</strong> pour la situation précise dans lequel il est utilisé.</li>
</ul>
</li>
<li class="nx-my-2">Le batching a encore plus d&#x27;intérêt quand on utilise la <strong>compression</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il n&#x27;est pas inhabituel d&#x27;obtenir des ratios de compression entre x5 et x7 sur du JSON.</li>
<li class="nx-my-2">L&#x27;essentiel de la performance de compression est obtenue déjà avec de <strong>petits batchs</strong>.</li>
<li class="nx-my-2">La compression est réalisée par le producer, et la décompression dans le consumer, donc ça a l&#x27;avantage de ne pas mettre de charge sur le serveur.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le serveur offre aussi la possibilité de modifier la compression de son côté si on le veut vraiment : avec la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">compression.type</code> côté broker, qui a par défaut la valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">producer</code>, et peut prendre une valeur de type de compression (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">gzip</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">snappy</code> etc.).</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;auteur recommande de <strong>toujours activer la compression pour les records textuels et binaires</strong> (sauf si on sait qu&#x27;ils ont une très grande entropie, c&#x27;est-à-dire que leur contenu est très variable et difficilement prévisible, donc difficilement compressible).</li>
<li class="nx-my-2">Côté algo, il conseille les heuristiques suivantes :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on a des clients legacy (avec une version inférieure à 2.1.0) :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">De base LZ4.</li>
<li class="nx-my-2">Si le réseau est identifié comme un bottleneck : Gzip.</li>
</ul>
</li>
<li class="nx-my-2">Si on a des clients récents :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">De base LZ4.</li>
<li class="nx-my-2">Si le réseau est identifié comme un bottleneck : ZStandard.</li>
</ul>
</li>
<li class="nx-my-2">Bien sûr, si on a un vrai besoin de fine tuner la performance, il faut faire des benchmarks avec chacun des algos dans notre contexte spécifique.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">13 - Replication and Acknowledgements<a href="#13---replication-and-acknowledgements" id="13---replication-and-acknowledgements" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le système de réplication fonctionne par <em>sequential consistency</em> : un leader par partition envoie la donnée aux followers.</li>
<li class="nx-my-2">Plus le replication factor est élevé, et plus l&#x27;acknowledgement des records peut être ralenti à cause du fait qu&#x27;il faut attendre le follower le plus lent.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour répondre à ce problème, chaque leader maintient dans ZooKeeper une liste des <strong>In-Sync Replicas</strong> (ISR), c&#x27;est-à-dire les followers qui ne dépassent pas un retard temporel spécifique vis-à-vis des records du leader.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut régler un nombre minimal de followers dans l&#x27;ISR avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">min.insync.replicas</code> (par défaut 1, mais l&#x27;auteur conseille au moins 2, pour toujours avoir au moins une autre copie à jour).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En dessous de ce nombre se trouvant dans l&#x27;ISR, le leader arrête d&#x27;accepter la publication de records et attend qu&#x27;un nombre suffisant de followers redeviennent éligibles à l&#x27;ISR.</li>
</ul>
</li>
<li class="nx-my-2">Le temps maximal de lag à partir duquel un follower est exclu de l&#x27;ISR est configuré avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">replica.lag.time.max.ms</code> (par défaut 10 secondes).</li>
<li class="nx-my-2">C&#x27;est les followers de l&#x27;ISR dont on attendra la confirmation pour une durabilité maximale, et non pas celle de l&#x27;ensemble des followers.</li>
<li class="nx-my-2">Le producer ne peut que dire s&#x27;il veut attendre l&#x27;acknowledgement de tous les followers (de l&#x27;ISR), du leader seulement, ou de personne. Il ne peut pas influer sur qui se trouve ou non dans l&#x27;ISR.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>Seuls les réplicas de l&#x27;ISR</strong> sont éligibles pour devenir <strong>leaders de partition</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Sauf si on a mis la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">unclean.leader.election</code> à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">true</code>.</li>
</ul>
</li>
<li class="nx-my-2">Quelle que soit l&#x27;approche choisie, elle aura des désavantages plus ou moins grands :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Avec un faible <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">min.insync.replicas</code> on risque de ne plus avoir de réplicas à jour pour prendre la main au moment où le leader est en échec.</li>
<li class="nx-my-2">Avec un <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">min.insync.replicas</code> élevé proche ou égal au replication factor, on risque d&#x27;avoir des réplicas lents qu&#x27;on est obligés d&#x27;attendre.</li>
<li class="nx-my-2">Avec un plus grand replication factor (la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">default.replication.factor</code>), et potentiellement plus de brokers, on risque quand même d&#x27;être lent parce qu&#x27;on a plus de réplicas à mettre à jour.</li>
</ul>
</li>
<li class="nx-my-2">On peut <strong>augmenter le replication factor de topics existants</strong>, mais ça nécessite de créer un fichier de config de réassignement sous forme JSON, avec l&#x27;ordre des réplicas qu&#x27;on préfèrerait pour chaque partition (pour le choix des nouveaux leaders d&#x27;une manière qui les répartit entre brokers).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour nous aider avec cette config, il y a l&#x27;outil <em style="color:#3d85c6;font-weight:bold;font-style:normal">kafka-reassign-tool</em> sur GitHub.</li>
<li class="nx-my-2">La création d&#x27;un réplica supplémentaire demande à copier les partitions pour lesquelles on augmente le replication factor, donc ça peut prendre du temps et occuper le cluster.</li>
</ul>
</li>
<li class="nx-my-2">Pour <strong>décommissionner un broker</strong>, il faut d&#x27;abord le vider de son rôle de leader pour toutes les partitions où il l&#x27;est.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut pour ça utiliser la même technique avec le fichier de config de réassignement, en indiquant pour toutes les partitions où il est leader, les IDs d&#x27;autres brokers.</li>
</ul>
</li>
<li class="nx-my-2">Concernant l&#x27;<strong>acknowledgement</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Quand un producer choisit de ne pas en recevoir (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks = 0</code>), il n&#x27;a plus de garantie de durabilité sur ce qu&#x27;il envoie (bien que la réplication se fasse comme d&#x27;habitude côté serveur), et il n&#x27;est plus non plus informé de l&#x27;offset des records qu&#x27;il publie (par retour de la méthode <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">send()</code> par exemple).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ca peut par exemple être utile dans un cas de traitement de données de température qu&#x27;on affiche en direct : la perte de quelques données n&#x27;est pas très grave.</li>
</ul>
</li>
<li class="nx-my-2">Quand un producer choisit d&#x27;en recevoir un quand seulement le leader a validé le record (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks = 1</code>), en réalité il n&#x27;y a pas beaucoup plus de garantie qu&#x27;avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks = 0</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le leader peut échouer à effectivement écrire le record (il répond avant que l&#x27;écriture soit complète), ou il peut lui-même être en situation d&#x27;échec juste après l&#x27;acknowledgement, et avant d&#x27;avoir envoyé le record aux autres réplicas.</li>
<li class="nx-my-2">En fait ça revient à se demander si la machine du leader est considérée comme plus fiable que celle du producer pour ce qui est de décider si un record est publié ou pas.</li>
<li class="nx-my-2">De manière générale ce mode est surtout utile <strong>dans les cas où la perte de quelques données est tolérable</strong>, mais où le client a besoin de connaître l&#x27;offset du record qu&#x27;il vient d&#x27;écrire.</li>
</ul>
</li>
<li class="nx-my-2">Quand un producer choisit de recevoir tous les acknowledgements (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks = -1</code> ou <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">all</code>), il a la garantie de durabilité maximale.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;auteur conseille comme heuristique par défaut d&#x27;adopter <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">-1</code> ou <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">all</code> pour la valeur de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">acks</code> (au lieu de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1</code> par défaut), et au moins <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">2</code> <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">pour min.insync.replicas</code> (au lieu de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1</code> par défaut) avec un replication factor d&#x27;au moins <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">3</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on est dans des cas où la perte de données est tolérable, alors on pourra diminuer ces contraintes.</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">14 - Data Retention<a href="#14---data-retention" id="14---data-retention" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les données de chaque partition sont par défaut dans des dossiers de la forme <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/tmp/kafka-logs/getting-started-0/</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le dossier contient un fichier nommé <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">leader-epoch-checkpoint</code>, qui contient toutes les réassignation de leader pour la partition. De cette manière, chaque réplica peut ignorer les messages d&#x27;un collègue broker qui se prendrait pour le leader de la partition sans l&#x27;être.</li>
<li class="nx-my-2">Le contenu des records se trouve dans fichiers nommés selon le 1er offset du record qu&#x27;ils ont, avec l&#x27;extension <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">.log</code>.</li>
<li class="nx-my-2">Chaque fichier de log a un index nommé de la même manière mais avec une extension <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">.index</code>. Il contient un map entre les offsets des records (ou des batchs) du fichier de log, et l&#x27;offset physique dans le fichier de log pour aller les lire.</li>
<li class="nx-my-2">On a enfin un autre fichier nommé pareil mais avec l&#x27;extension <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">.timeindex</code>, et qui contient un map entre des timestamps des records et l&#x27;offset physique dans le fichier de log.</li>
</ul>
</li>
<li class="nx-my-2">Kafka a des propriétés configurables, liées à la taille des fichiers de log et à leur ancienneté, pour contrôler le moment où on <strong>switch au fichier suivant</strong> pour écrire.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par exemple <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.segment.bytes</code> (par défaut 1 GB), <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.roll.hours</code> (par défaut 1 semaine).</li>
<li class="nx-my-2">On peut aussi configurer un temps aléatoire de décalage du switch, pour que l&#x27;ensemble des partitions ne changent pas de fichier de log en même temps.</li>
</ul>
</li>
<li class="nx-my-2">Les fichiers d&#x27;index ont une place pré-allouée, dont la taille est contrôlable par une propriété.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut de la même manière activer la pré-allocation des fichiers de log, pour gagner en performance sur certains filesystems.</li>
</ul>
</li>
<li class="nx-my-2">Le script <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-dump-log.sh</code> dans les outils d&#x27;admin de Kafka permet de lire le contenu des fichiers qui composent les logs.</li>
<li class="nx-my-2">Il existe des <strong>cleanup policies</strong> qui sont de deux types : supprimer les anciens records, ou faire de la compaction pour gagner en place.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>log.cleanup.policy</strong> permet de contrôler le type de policy, cross-topic ou pour un topic spécifique.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par défaut la valeur est <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">delete</code>, l&#x27;autre valeur étant <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">compact</code>. On peut spécifier les deux en même temps, en les séparant par une virgule.</li>
</ul>
</li>
<li class="nx-my-2">Le cleanup ne s&#x27;applique qu&#x27;aux fichiers de log <strong>inactifs</strong>, c&#x27;est-à-dire les fichiers de log dont on a déjà switché vers un autre fichier.</li>
<li class="nx-my-2">Quand la policy est <strong>delete</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Un background process va régulièrement (toutes les <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.retention.check.interval.ms</code>, par défaut 5 minutes) vérifier pour chaque fichier de log inactif s&#x27;il est sujet à être supprimé ou non, en fonction des règles de rétention configurées (par exemple <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.retention.bytes</code> (non configuré par défaut), <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.retention.hours</code> (par défaut 1 semaine)).</li>
<li class="nx-my-2">Avec les valeurs par défaut, un fichier de log sera supprimé au bout d&#x27;1 semaine. Par contre, il sera supprimé d&#x27;un coup. Donc si on n&#x27;avait qu&#x27;un seul fichier qui n&#x27;avait pas atteint la taille d&#x27;1 GB pour switch de fichier avant les 1 semaine, on va perdre tous les records d&#x27;un coup, et écrire les nouveaux dans un nouveau fichier.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on veut une plus grande granularité, on peut configurer de plus petites valeurs pour pour le switch de fichier de log actif (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.segment.bytes</code> ou <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.roll.hours</code>).</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Quand la policy est <strong>compact</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La compaction est utile par exemple dans le cas où on a des <strong>events de type ECST</strong> (l&#x27;auteur ne mentionne pas le terme).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Normalement il faut une logique en deux temps : hydrater notre app downstream avec les données de l&#x27;app upstream, puis laisser l&#x27;app upstream publier ses changements sur Kafka.</li>
<li class="nx-my-2">Pour éviter d&#x27;avoir ce fonctionnement en deux temps, la compaction permet de publier dès le début les ECST dans Kafka, et de ne pas avoir besoin de l&#x27;autre mode puisque <strong>Kafka gardera toujours au moins le record le plus récent pour chaque entité</strong>.</li>
<li class="nx-my-2">Par contre ça ne marche qu&#x27;avec les events qui ont la totalité de la donnée de l&#x27;entité et qui donc “déprécient” les events précédents pour cette entité. Ça ne marche pas avec les events qui indiquent seulement les champs qui ont changé dans l&#x27;entité.</li>
</ul>
</li>
<li class="nx-my-2">La compaction consiste à transformer Kafka en snapshot, où on ne garde que les données les plus récentes pour chaque entité, qu&#x27;on <strong>différencie par la key</strong> associée au record.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La lecture de l&#x27;ensemble du topic prendra donc un temps proportionnel au nombre de keys différents dont il existe des records.</li>
</ul>
</li>
<li class="nx-my-2">D&#x27;un point de vue technique, la compaction est faite par des threads en arrière plan.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Côté config :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Leur nombre est contrôlé par <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.cleaner.threads</code>, par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1</code>.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.cleaner.min.cleanable.ratio</code> (par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">0.5</code>) indique le ratio de log “sale“ à partir duquel il sera éligible à être compacté.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.cleaner.min.compaction.lag.ms</code> (par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">0</code>) permet d&#x27;indiquer un temps minimal avant qu&#x27;un record ne puisse faire l&#x27;objet de compaction. Sachant que ça ne peut pas concerner le fichier de log <em>actif</em>, mais seulement ceux où il y a déjà eu un switch de fichier.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.cleaner.min.compaction.lag.ms</code> (par défaut infini) permet d&#x27;indiquer un temps maximal à partir duquel le log sera quand même compacté, même s&#x27;il ne satisfaisait pas le ratio de “saleté”.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">log.cleaner.delete.retention.ms</code> (par défaut 24 heures) indique la durée de vie des <em>tombstones</em>.</li>
<li class="nx-my-2">On peut aussi définir ces configs par topic (sauf pour le nombre de threads de compaction).</li>
</ul>
</li>
<li class="nx-my-2">Pour calculer le <strong>ratio de “saleté”</strong>, Kafka maintient un <em>cleaner point</em> correspondant au point jusqu&#x27;où la compaction a déjà été faite, pour chaque fichier de log.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le ratio consiste à diviser le nombre de records pas encore traités par le nombre de records existants dans la partie déjà traitée.</li>
</ul>
</li>
<li class="nx-my-2">La compaction laisse les records <strong>dans le même ordre</strong>, et <strong>ne change pas leur offset</strong>. Elle va juste éliminer des records.</li>
<li class="nx-my-2">Les <strong>tombstones</strong> sont créés par les producers pour indiquer à Kafka que les entités d&#x27;une key particulière ne sont plus utiles.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce sont simplement des records, avec une valeur nulle, et la key pour laquelle on veut faire la suppression.</li>
<li class="nx-my-2">La raison pour laquelle ils restent un temps minimal (par défaut 24h) est de s&#x27;assurer que les consumers ont eu le temps d&#x27;avoir l&#x27;info de suppression du record, pour éviter qu&#x27;ils gardent l&#x27;entité en base alors qu&#x27;elle n&#x27;est plus censée exister.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">On peut aussi <strong>combiner compaction et deletion</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette possibilité est utile dans des cas particuliers où les events perdent rapidement leur intérêt.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut alors potentiellement avoir une compaction plus agressive vu qu&#x27;on limite la taille des records en supprimant les plus anciens.</li>
</ul>
</li>
<li class="nx-my-2">Un exemple peut être le topic <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__consumer_offsets</code> qui compacte pour que le group coordinator puisse rapidement reconstruire l&#x27;état des consumers, et supprime les anciens offsets pour les groupes qui n&#x27;ont pas été actifs depuis longtemps pour éviter de trop grossir.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">15 - Group Membership and Partition Assignment<a href="#15---group-membership-and-partition-assignment" id="15---group-membership-and-partition-assignment" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les <strong>consumer groups</strong> permettent de faire du load balancing au niveau de la consommation.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka garantit qu&#x27;il y aura <strong>au plus un consumer d&#x27;un même groupe par partition</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">“au plus” pour prendre en compte le cas où aucun consumer ne serait disponible dans le groupe.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;assignation des consumers se passe en deux temps :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>1 - La phase group membership</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il s&#x27;agit d&#x27;identifier les consumers d&#x27;un groupe, et d&#x27;élire un <strong>group leader</strong> parmi eux, pour que celui-ci décide des assignations partition / consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Les consumers envoient un message au <strong>broker qui est coordinator</strong> pour ce group, pour s&#x27;identifier comme membres de ce groupe.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ils savent qui est leur coordinator parce que son id leur est renvoyé par un des brokers, qui lui même peut le savoir par un mécanisme déterministe de hachage entre le group id et une des partitions : le broker leader de cette partition devient le coordinator du group.</li>
</ul>
</li>
<li class="nx-my-2">2 - Le coordinator attend un certain temps avant de répondre, pour que tous les consumers aient pu s&#x27;identifier comme membres du groupe, et pour éviter les nombreux rebalancings au début.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le délai est appliqué quand le groupe est vide.</li>
<li class="nx-my-2">Le délai est contrôlable avec <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">group.initial.rebalance.delay.ms</code> (par défaut 3 secondes).</li>
<li class="nx-my-2">C&#x27;est typiquement inutile dans les scénarios où il n&#x27;y a qu&#x27;un consumer, comme dans des tests d&#x27;intégration par exemple où on peut le mettre à 0.</li>
</ul>
</li>
<li class="nx-my-2">3 - Il renvoie une réponse à chacun, contenant les IDs des consumers du groupe et l&#x27;ID du consumer leader.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>2 - La phase state synchronisation</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Le group leader va faire l&#x27;assignation des partitions aux consumers dont il a reçu la liste, et envoyer ça au coordinator.</li>
<li class="nx-my-2">2 - Le coordinator à son tour renvoie les assignations à chaque consumer.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">A chaque fois qu&#x27;un consumer rejoint un groupe existant, le coordinator oblige les autres consumers à se réidentifier, et se voir potentiellement réassigner des partitions (on appelle ça le <strong>rebalancing</strong>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pendant le rebalancing, les consumers se verront refuser toutes leurs opérations (y compris heartbeats) par une réponse <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">REBALANCE_IN_PROGRESS</code>.</li>
<li class="nx-my-2">A chaque rebalancing, le coordinator va assigner à chaque consumer un id qui est incrémenté monotoniquement. Donc un consumer zombie qui aurait oublié de se réidentifier serait rejeté la prochaine fois qu&#x27;il voudrait consommer.</li>
<li class="nx-my-2">Le client met à disposition la possibilité d&#x27;enregistrer des callbacks sur les events d&#x27;un rebalancing :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">onPartitionsRevoked()</code> est appelé dès que la consommation doit s&#x27;arrêter pour que le rebalancing puisse avoir lieu.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">onPartitionsAssigned()</code> indique au client les éventuelles nouvelles partitions qui lui ont été assignées.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">onPartitionLost()</code> indique d&#x27;éventuelles partitions perdues par le consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça peut se produire si le consumer n&#x27;avait pas émis de heartbeats et était considéré en échec.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le rebalancing par défaut (<em>eager rebalancing</em>) se fait en une étape.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il implique donc que les consumers doivent à chaque fois partir du principe que l&#x27;ensemble des assignations de partition sont potentiellement révoquées et cleaner les messages en cours de traitement.</li>
<li class="nx-my-2">L&#x27;<strong>incremental cooperative rebalancing</strong> permet d&#x27;éviter ça en plaçant les assignations à la fin, en utilisant éventuellement plusieurs étapes :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Une seule étape s&#x27;il n&#x27;y a que de nouvelles assignations de partitions.</li>
<li class="nx-my-2">S&#x27;il y a aussi des révocations : une première étape de révocations, et une deuxième étape d&#x27;assignations.</li>
</ul>
</li>
<li class="nx-my-2">Pour que l&#x27;incremental cooperative rebalancing soit plus efficace, et contrebalance le fait qu&#x27;il nécessite plus d&#x27;appels réseau, il faut que la stratégie d&#x27;assignation de partition soit <strong>sticky</strong> (c&#x27;est-à-dire qu&#x27;on essaye au maximum de garder les assignations qui existent pendant le rebalancing).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Dans les systèmes distribués, il y a deux propriétés importantes : la <strong>liveness</strong> qui est le fait qu&#x27;un système continue d&#x27;opérer et de progresser dans ses tâches, et la <strong>safety</strong> qui est le fait que les invariants du système soient préservés.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka satisfait la liveness par :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les checks réguliers d&#x27;availability des consumers par le système de heartbeats à envoyer avant un timeout.</li>
<li class="nx-my-2">La vérification que les consumers progressent, en s&#x27;assurant qu&#x27;ils appellent régulièrement <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code> avant de dépasser un timeout.</li>
</ul>
</li>
<li class="nx-my-2">Plus les valeurs des deux timeouts sont petites et plus le client détectera vite les échecs, mais au prix de plus de consommation de ressources et de plus de faux positifs.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Globalement l&#x27;<strong>auteur trouve ces valeurs par défaut raisonnables</strong> dans la plupart des cas.</li>
</ul>
</li>
<li class="nx-my-2">Dans le cas où on doit retenter une requête vers un composant externe (DB, broker etc) qui échoue plusieurs fois, on risque d&#x27;échouer nous-mêmes à respecter le timeout prouvant qu&#x27;on progresse (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.poll.interval.ms</code>), on alors 5 possibilités :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Mettre une très grande valeur à <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">max.poll.interval.ms</code>, pour “désactiver” le timeout.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il s&#x27;agit d&#x27;un cas où on veut que l&#x27;ordre soit absolument respecté, et que les actions pour chaque record soient absolument réalisées, au prix d&#x27;une potentielle attente jusqu&#x27;à ce que la ressource externe réponde correctement.</li>
<li class="nx-my-2">Le problème c&#x27;est qu&#x27;on ne prend pas en compte qu&#x27;on pourrait avoir un problème en interne, notamment des bugs dans le consumer lui-même, et que notre timeout nous protégeait aussi de ça.</li>
</ul>
</li>
<li class="nx-my-2">2 - Mettre une valeur raisonnable pour le timeout. Dans ce cas, tant que le service externe est down, le consumer va recommencer jusqu&#x27;au timeout, et être rebalancé (exclu puis réintégré).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">C&#x27;est le même comportement que le 1- où on veut faire les records dans l&#x27;ordre coûte que coûte, mais là on règle les éventuels problèmes de consumer bloqué.</li>
<li class="nx-my-2">Il y a par contre un risque de perdre en performance à force d&#x27;enchaîner les rebalancings.</li>
</ul>
</li>
<li class="nx-my-2">3 - Détecter nous mêmes dans le consumer le fait qu&#x27;on va bientôt dépasser le timeout, et se déconnecter après avoir nettoyé ses tâches en cours, pour se reconnecter tout de suite après.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En fait, vu qu&#x27;on se déconnecte/reconnecte, on va entraîner un rebalancing de fait.</li>
<li class="nx-my-2">Le petit avantage par rapport à la 2- c&#x27;est qu&#x27;on va pouvoir faire des checks supplémentaires localement sur le fait de ne processer le record qu&#x27;une fois.</li>
</ul>
</li>
<li class="nx-my-2">4 - Mettre en place une deadline par record, et si la deadline est dépassée, considérer qu&#x27;il a été traité en passant au suivant, mais le republier dans le topic pour qu&#x27;il soit retraité plus tard.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cette solution implique que l&#x27;ordre de traitement des records n&#x27;est pas essentiel.</li>
<li class="nx-my-2">On pourrait aussi avoir un temps maximal ou un nombre de retries maximal dans le record, indiquant combien de temps ou de fois il faut continuer à essayer de le republier avant que ça ne serve plus à rien, dans le cas où il devient obsolète avec le temps.</li>
<li class="nx-my-2">Les consumer groups étant indépendants et pouvant lire dans un même topic, requeuer un message derrière le topic juste parce qu&#x27;un consumer group n&#x27;a pas pu le traiter à temps n&#x27;est pas vraiment ce qu&#x27;on veut.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Au lieu de ça, on peut avoir une topologie de type <em>fanout</em>, c&#x27;est-à-dire un topic qui publie dans un fanout group, qui lui-même publie dans un topic par consumer group. Et dans ce deuxième niveau on pourra requeuer un message non géré par un consumer groupe spécifique.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">5 - Mettre en place une deadline comme dans le 4-, mais sans requeuer le record du tout.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il peut être intéressant, tout comme pour le 4-, de penser à mettre les records non traités dans une <em>dead letter queue</em> pour pouvoir investiguer la lenteur plus tard.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Malgré les garanties apportées par Kafka, il est possible que <strong>deux consumers traitent le même record</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça arrive dans le cas suivant :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Un consumer met beaucoup de temps à traiter un record, et dépasse le timeout pour appeler <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">poll()</code>.</li>
<li class="nx-my-2">2 - Il se fait exclure parce que son thread responsable des heartbeats n&#x27;en émet plus et demande même explicitement à être révoqué.</li>
<li class="nx-my-2">3 - Le coordinator révoque le consumer et fait un rebalancing pour assigner sa partition à un autre consumer.</li>
<li class="nx-my-2">4 - Le nouveau consumer commence à traiter les records non commités.</li>
<li class="nx-my-2">5 - pendant ce temps, le consumer révoqué continue de traiter son record en cours, sans savoir qu&#x27;il a été arrêté.</li>
</ul>
</li>
<li class="nx-my-2">Pour éviter ça, Kafka ne propose pas grand chose. L&#x27;auteur propose 3 approches à faire soi-même :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Se débrouiller pour que le consumer <strong>ne dépasse jamais le timeout</strong>, et que sinon on gère les conséquences à la main pour ne pas avoir de rebalancing.</li>
<li class="nx-my-2">2 - Utiliser un <strong>distributed lock manager</strong> (DLM) pour protéger les sections critiques d&#x27;être traitées en même temps par deux consumers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La protection agit sur le fait de traiter <em>en même temps</em>, pas le fait de traiter plusieurs fois en général.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ceci dit, on peut du coup vérifier qu&#x27;on n&#x27;a pas déjà traité la section critique du record avant de la traiter à nouveau.</li>
<li class="nx-my-2">Attention à ne pas être tenté de faire l&#x27;optimisation de faire déconnecter/reconnecter le consumer dans le cas où on remarque que le record a déjà été traité : le consumer qui l&#x27;a traité n&#x27;a peut-être pas encore commité, et donc on risquerait de le retraiter à nouveau.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;impact du DLM sur le throughput et la latence peuvent être minimisés en regroupant les records du buffer, par exemple par partition, et en faisant le lock avant et après le traitement de chacun de ces lots.</li>
<li class="nx-my-2">A la place du DLM on pourrait aussi avoir n&#x27;importe quel store persistant, comme Redis ou une DB.</li>
</ul>
</li>
<li class="nx-my-2">3 - Utiliser un <strong>process qui vérifie régulièrement</strong> le process qui tourne pour consommer les records, pour s&#x27;assurer qu&#x27;il consomme bien régulièrement.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">S&#x27;il est bloqué depuis un certain temps, le process vérificateur le restart avant que le timeout côté Kafka soit déclenché.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;idée des <strong>static members</strong> va très bien avec le fait d&#x27;avoir un système de health check externe à Kafka : par exemple Kubernetes qui s&#x27;assurerait de détecter les consumers en échec, et de les arrêter puis restarter.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Côté liveness, ça peut permettre d&#x27;éviter des rebalancings de la part de Kafka, et donc d&#x27;avoir un throughput plus important, au prix de certaines partitions spécifiques qui n&#x27;avancent plus pendant un temps plus long qu&#x27;en mode non static.</li>
<li class="nx-my-2">Côté safety, Kubernetes peut jouer le rôle d&#x27;orchestrateur pour s&#x27;assurer que les partitions ne sont pas traitées par plusieurs consumers en même temps.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">La raison pour laquelle l&#x27;assignation des partitions se passe dans un consumer leader, c&#x27;est de permettre le <strong>changement de stratégie d&#x27;assignation</strong> pour chaque consumer, plutôt que quelque chose de commun en tant que config Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il existe 4 assignors disponibles pour choisir ces stratégies :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le <strong>range assignor</strong> est l&#x27;assignor par défaut, il consiste à classer les partitions pour un même topic et les consumers dans l&#x27;ordre du plus petit au plus grand, et ensuite d&#x27;attribuer des groupes de partitions de part égales aux consumers successifs.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Et on recommence la même chose pour chaque topic.</li>
<li class="nx-my-2">Si le nombre de partitions n&#x27;est pas divisible par le nombre de consumers, les premiers consumers se verront attribuer une partition de plus.</li>
<li class="nx-my-2">Son désavantage c&#x27;est qu&#x27;il assigne les partitions équitablement par topic, mais si on prend en compte l&#x27;ensemble des partitions existantes dont les consumers doivent s&#x27;occuper, on peut tomber sur une répartition assez inégale.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça se produit en particulier quand le nombre de partition par topic est plus petit que le nombre de consumers : les premiers consumers reçoivent une partition de chaque topic, alors que les derniers n&#x27;en reçoivent pas.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>round robin assignor</strong> consiste à rassembler les partitions de tous les topics, puis de les attribuer un par un, dans l&#x27;ordre, aux consumers, en rebouclant sur la liste de consumers s&#x27;il y a plus de partitions que de consumers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La répartition est bien meilleure que pour le range assignor, puisqu&#x27;elle est cross-topic.</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>sticky assignor</strong> consiste à assigner de manière à peu près équilibrée, mais surtout s&#x27;évertue à préserver le plus possible les assignations déjà faites, quand il faut faire une réassignation.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La répartition est de la même qualité que pour le round robin assignor, mais celui-ci minimise le nombre de partitions changées de main pendant un rebalancing.</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>cooperative sticky assignor</strong> consiste à faire la même chose que le sticky assignor, mais en utilisant le <em>cooperative rebalancing protocol</em> qui permet de réduire les pauses de rebalancing.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les consumers ne sont plus obligés de se préparer à la révocation de toutes leurs partitions à chaque rebalancing. Ils savent lesquelles seront révoquées, et ensuite lesquelles leur seront assignées.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Pour <strong>changer la stratégie d&#x27;assignation</strong>, on ne peut pas simplement mettre à jour la propriété de config qui le fait (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">partition.assignment.strategy</code>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le premier consumer qui sortirait du groupe pour y revenir avec la nouvelle stratégie provoquerait un problème d&#x27;inconsistance de stratégie au niveau de ce groupe.</li>
<li class="nx-my-2">On assigne d&#x27;abord l&#x27;ancienne stratégie et la nouvelle, puis on supprime l&#x27;ancienne. Au final on aura eu 2 bounces.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">16 - Security<a href="#16---security" id="16---security" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka n&#x27;est pas configuré par défaut pour fonctionner de manière sécurisée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par défaut, n&#x27;importe quel client peut se connecter, y compris à ZooKeeper.</li>
<li class="nx-my-2">Les connexions ne sont pas chiffrées.</li>
<li class="nx-my-2">Même une fois l&#x27;authentification mise en place, les autorisations sont maximales.</li>
</ul>
</li>
<li class="nx-my-2">La première sécurité est le <strong>blocage au niveau réseau</strong> avec un firewall.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur propose une topologie réseau en 4 blocs séparés par des firewalls :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le bloc ZooKeeper, accédé uniquement par les brokers.</li>
<li class="nx-my-2">Le bloc Kafka brokers, accédé par les clients.</li>
<li class="nx-my-2">Le bloc clients : consumers, publishers, admin clients.</li>
<li class="nx-my-2">Le bloc externe qui passe par internet, et peut contenir un site distant, ou encore des télétravailleurs accédant via VPN.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Ensuite il faut activer le <strong>chiffrement TLS</strong> supporté par Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Chaque broker a besoin d&#x27;une clé RSA et d&#x27;un certificat CA, correspondant à son hostname.</li>
<li class="nx-my-2">La configuration SSL/TLS peut se faire dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">server.properties</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il faut notamment utiliser le protocole existant <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">SSL</code> sur un port différent de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">PLAINTEXT</code>, à la fois pour <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">listeners</code> et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">advertised.listeners</code>.</li>
<li class="nx-my-2">Pour activer le chiffrement pour les communications inter-broker, on peut ajouter <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">inter.broker.listener.name=SSL</code>.</li>
</ul>
</li>
<li class="nx-my-2">Il suffit ensuite de connecter le client sur le bon port de Kafka, en indiquant les bonnes creds et le protocole utilisé.</li>
<li class="nx-my-2">Une fois qu&#x27;on s&#x27;est assuré que la connexion chiffrée fonctionne, l&#x27;auteur recommande de désactiver le socket non chiffré dans le serveur, en enlevant la version qui utilise <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">PLAINTEXT</code> dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">listeners</code> et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">advertised.listeners</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut même configurer le firewall pour interdire les connexions sur le port 9092.</li>
</ul>
</li>
<li class="nx-my-2">Kafka n&#x27;a pas de <strong>mécanisme de chiffrement de la donnée elle-même</strong>, par défaut elle sera stockée en clair sur le filesystem des brokers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Une des possibilités peut être d&#x27;utiliser un chiffrement au niveau du filesystem ou du disque dur entier des machines des brokers.</li>
<li class="nx-my-2">La méthode la plus sûre est de recourir à du <strong>chiffrement de bout en bout</strong> de la donnée, en chiffrant dans le publisher, et déchiffrant dans le consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il existe plusieurs projets open source qui permettent de le faire. Par exemple, le projet <em style="color:#3d85c6;font-weight:bold;font-style:normal">Kafka Encryption</em>.</li>
<li class="nx-my-2">Si on publie des messages déjà chiffrés, il devient inutile d&#x27;activer la compression dans Kafka, puisque l&#x27;entropie des messages sera alors maximale.</li>
<li class="nx-my-2">Le chiffrement de bout en bout ne rend pas l&#x27;utilisation de TLS inutile.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">TLS protège l&#x27;ensemble du record, y compris les headers par exemple.</li>
<li class="nx-my-2">Il protège contre les attaques man in the middle, en assurant l&#x27;identité de l&#x27;émetteur.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Kafka supporte plusieurs types d&#x27;<strong>authentification</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le <strong>mutual TLS</strong> permet d&#x27;utiliser le mécanisme TLS habituellement utilisé pour que le client fasse confiance au serveur aussi dans l&#x27;autre sens : le client lui aussi envoie un certificat signé par un CA auquel le serveur fait confiance.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Côté serveur, on peut activer la fonctionnalité avec la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ssl.client.auth</code> :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Elle vaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">none</code> par défaut.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">required</code> permet de forcer les clients à fournir un certificat valide s&#x27;ils veulent se connecter.</li>
<li class="nx-my-2">Il y a une 3ème option utile pour faire une migration progressive : <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">requested</code> permet d&#x27;accepter l&#x27;authentification par ce moyen, mais sans le rendre obligatoire le temps que tous les clients aient été migrés.</li>
</ul>
</li>
<li class="nx-my-2">Côté client, il faut obtenir un certificat certifié par un CA valide du point de vue du serveur, et se connecter avec les propriétés de config qui sont le miroir de celles qu&#x27;utilise le serveur pour lui-même configurer TLS.</li>
<li class="nx-my-2">Pour obtenir l&#x27;information sur l&#x27;<strong>identité du client</strong> qui se connecte, c&#x27;est par défaut le champ CN du certificat qui sera utilisé.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ssl.principal.mapping.rules</code> permet de personnaliser le champ à prendre par des règles de type regex.</li>
<li class="nx-my-2">Par contre, la fiabilité de la méthode pour déterminer l&#x27;identité dépend de la rigueur avec laquelle les certificats sont établis :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si un des clients peut mettre l&#x27;identité d&#x27;un autre client dans le champ CN d&#x27;un certificat qu&#x27;il fait générer par l&#x27;autorité de confiance, alors il pourra se faire passer pour l&#x27;autre client.</li>
</ul>
</li>
<li class="nx-my-2">Un autre problème aussi c&#x27;est que Kafka ne permet pas de révoquer un certificat pour un client particulier.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le mieux qu&#x27;on puisse faire c&#x27;est de déployer un nouveau CA, et de faire signer tous les certificats des clients par ce CA.</li>
<li class="nx-my-2">Il faut aussi penser à utiliser des CA différents si on a plusieurs clusters Kafka.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;authentification mutual TLS ne peut pas être utilisée en même temps que d&#x27;autres types d&#x27;authentification au niveau applicatif, même si la mutual TLS se trouve dans une couche réseau différente.</li>
</ul>
</li>
<li class="nx-my-2"><strong>SASL</strong> (Simple Authentication and Security Layer) consiste à ajouter une méthode d&#x27;authentification à un protocole utilisateur.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il est en général utilisé avec du TLS.</li>
<li class="nx-my-2">L&#x27;une des variantes supportées est <strong>GSSAPI</strong> (Generic Security Service API), aussi connu sous le nom de son implémentation principale qui est Kerberos.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Cet outil va avec l&#x27;usage de répertoires centralisés type Active Directory.</li>
<li class="nx-my-2">Il est surtout adapté aux utilisateurs individuels, mais Kafka a besoin d&#x27;avoir une authentification plutôt orientée autour de <em>service accounts</em>, parce qu&#x27;on ne peut pas démarrer et arrêter un client à chaque interaction utilisateur.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le problème avec l&#x27;approche <em>service accounts</em> c&#x27;est que Kerberos n&#x27;étant pas forcément compatible avec toutes les ressources (par exemple Redis), on va pouvoir désactiver un account mais sans être sûr que l&#x27;ensemble des ressources le sont pour cet account.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;auteur trouve que Kerberos est un système complexe pour ce qu&#x27;il apporte, et conseille plutôt les autres méthodes SASL.</li>
</ul>
</li>
<li class="nx-my-2">Les autres variantes SASL supportées par Kafka sont <strong>PLAIN</strong> et <strong>SCRAM</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">PLAIN est le diminutif de plaintext, pour dire que le user et mot de passe sont transmis en clair.</li>
<li class="nx-my-2">SCRAM est l&#x27;acronyme de <em>Salted Challenge Response Authentication Mechanism</em>, et il a la particularité de <strong>ne pas impliquer d&#x27;envoyer les credentials directement au serveur</strong>. Il apporte donc une meilleure sécurité.</li>
<li class="nx-my-2">Comme dit plus haut, l&#x27;authentification SASL n&#x27;est pas compatible avec l&#x27;authentification SSL côté client (avec le client qui fournit un certificat signé par un CA de confiance) : Kafka ne saurait pas quoi prendre comme identifiant entre le username dans SASL et le champ CN du certificat.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on fournit les deux, la configuration pour l&#x27;authentification SSL côté client ne sera pas prise en compte.</li>
</ul>
</li>
<li class="nx-my-2">Avec SCRAM, les versions hashées des credentials valides sont stockées dans ZooKeeper, par exemple avec le script <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-config.sh</code>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">PLAIN quant à lui les stocke en clair dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">server.properties</code>.</li>
</ul>
</li>
<li class="nx-my-2">On peut aussi utiliser SASL pour la communication inter-broker au lieu de juste SSL.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Attention à bien protéger le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">server.properties</code> qui va du coup contenir le username et password en clair, par exemple avec un petit <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">chmod 600</code>.</li>
<li class="nx-my-2">Une autre solution peut être de créer un fichier dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">config/</code> qu&#x27;on protège, et d&#x27;y mettre la config jaas. Il faudra alors passer ce fichier dans l&#x27;option CLI <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">java.security.auth.login.config</code> au moment de démarrer le broker.</li>
</ul>
</li>
<li class="nx-my-2">On peut à chaque fois utiliser <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">netstat -an | egrep &quot;9092|9093|9094&quot;</code> pour vérifier sur quels ports il y a Kafka en écoute et sur quels ports il y a une connexion établie.</li>
</ul>
</li>
<li class="nx-my-2">La version de SASL avec <strong>OAuth bearer</strong> est là seulement dans un objectif de <strong>testing</strong>. Elle n&#x27;est pas sécurisée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;application peut spécifier un user arbitraire dans un token JWT.</li>
<li class="nx-my-2">On peut utiliser une implémentation open source comme <em>Kafka OAuth</em>.</li>
</ul>
</li>
<li class="nx-my-2">Les <strong>delegation tokens</strong> sont un mécanisme complémentaire à SASL, permettant de faciliter la gestion des credentials sur un grand nombre de brokers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour Kerberos il va s&#x27;agir de remplacer le déploiement des TGT ou keytab, et pour PLAIN et SCRAM ça va être les user / password.</li>
<li class="nx-my-2">Les delegation tokens sont limités dans le temps et donc permettent de ne pas compromettre les vrais credentials.</li>
<li class="nx-my-2">C&#x27;est particulièrement pratique dans le cas où les brokers sont créés de manière éphémère dans des workers.</li>
<li class="nx-my-2">Il faut faire la configuration côté broker en mettant en place <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">delegation.token.master.key</code> à la même valeur pour tous les brokers du cluster.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On crée ensuite les tokens avec une commande CLI <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-delegation-tokens.sh</code>.</li>
<li class="nx-my-2">Le token doit être renouvelé avant la période d&#x27;expiration (par défaut 1 jour) avec le même fichier de commande CLI.</li>
</ul>
</li>
<li class="nx-my-2">Côté client, il faut indiquer qu&#x27;on utilise l&#x27;authentification avec delegation token, et indiquer les valeurs de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">TOKENID</code> et <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">HMAC</code> qu&#x27;on a pu récupérer au moment de créer le token sur le broker.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">On peut configurer une <strong>authentification sur ZooKeeper</strong>, en utilisant SASL.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça concerne du coup les brokers et les clients admin.</li>
<li class="nx-my-2">ZooKeeper a en plus un mécanisme d&#x27;autorisation à base d&#x27;ACL, permettant d&#x27;attribuer 5 types de droits aux utilisateurs anonymes et utilisateurs authentifiés par SASL.</li>
<li class="nx-my-2">De l&#x27;aveu de l&#x27;auteur, ajouter une authentification à un ZooKeeper qu&#x27;on a déjà isolé dans un réseau à part peut être excessif. Le niveau de sécurité dont on a besoin dépendra du contexte.</li>
<li class="nx-my-2">Pour activer l&#x27;authentification, il faut modifier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">zookeeper.properties</code> et y ajouter la config pour activer SASL.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il ne faut pas oublier de changer les autorisations qui existent pour les utilisateurs anonymes avec la commande CLI <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">zookeeper-security-migration.sh</code>.</li>
</ul>
</li>
<li class="nx-my-2">Il faut ensuite activer l&#x27;authentification sécurisée à ZooKeeper depuis le broker, en ajoutant la propriété <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">zookeeper.set.acl=true</code>, et en redémarrant le broker avec l&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">java.security.auth.login.config</code> pointant vers le fichier de config contenant les identifiants SASL.</li>
</ul>
</li>
<li class="nx-my-2">Les <strong>clients admin</strong>, que ce soit en script CLI ou de type Kafdrop, doivent aussi être configurés pour se connecter aux brokers qui ont une authentification activée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour les scripts CLI, on peut changer le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">client.properties</code>.</li>
<li class="nx-my-2">Pour Kafdrop, il faut modifier le fichier <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka.properties</code>.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Concernant l&#x27;<strong>autorisation</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Kafka a un système d&#x27;autorisations sous forme d&#x27;ACL centrées sur les ressources.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il s&#x27;agit d&#x27;un système distinct de celui de ZooKeeper.</li>
</ul>
</li>
<li class="nx-my-2">On a la possibilité d&#x27;autoriser des droits :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Par utilisateur.</li>
<li class="nx-my-2">Par host.</li>
<li class="nx-my-2">Pour un type de ressource particulier (par exemple Topic ou Group).</li>
<li class="nx-my-2">Pour un pattern spécifique à appliquer aux ressources (par exemple toutes les ressources commençant par un préfix, ou avec des <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">*</code> pour dire qu&#x27;on peut avoir n&#x27;importe quoi dans une partie du nom).</li>
<li class="nx-my-2">Pour une opération particulière (par exemple <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Read</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Write</code>, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Describe</code> etc.).</li>
</ul>
</li>
<li class="nx-my-2">Pour commencer, il faut activer l&#x27;autorisation dans le serveur en ajoutant la classe d&#x27;autorisation et la liste des super users dans <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">server.properties</code> :<!-- -->
<div class="nextra-code-block nx-relative nx-mt-6 first:nx-mt-0"><pre class="nx-bg-primary-700/5 nx-mb-4 nx-overflow-x-auto nx-rounded-xl nx-subpixel-antialiased dark:nx-bg-primary-300/10 nx-text-[.9em] contrast-more:nx-border contrast-more:nx-border-primary-900/20 contrast-more:nx-contrast-150 contrast-more:dark:nx-border-primary-100/40 nx-py-4" data-language="text" data-theme="default"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr" data-language="text" data-theme="default"><span class="line"><span style="color:var(--shiki-color-text)">authorizer.class.name=kafka.security.auth.SimpleAclAuthorizer</span></span>
<span class="line"><span style="color:var(--shiki-color-text)">super.users=User:admin</span></span></code></pre><div class="nx-opacity-0 nx-transition [div:hover&gt;&amp;]:nx-opacity-100 focus-within:nx-opacity-100 nx-flex nx-gap-1 nx-absolute nx-m-[11px] nx-right-0 nx-top-0"><button class="nextra-button nx-transition-all active:nx-opacity-50 nx-bg-primary-700/5 nx-border nx-border-black/5 nx-text-gray-600 hover:nx-text-gray-900 nx-rounded-md nx-p-1.5 dark:nx-bg-primary-300/10 dark:nx-border-white/10 dark:nx-text-gray-400 dark:hover:nx-text-gray-50 md:nx-hidden" title="Toggle word wrap"><svg viewBox="0 0 24 24" width="24" height="24" class="nx-pointer-events-none nx-h-4 nx-w-4"><path fill="currentColor" d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button></div></div>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les super users sont séparés par des point-virgules.</li>
<li class="nx-my-2">A partir de là, seuls les super users auront la possibilité de faire des choses. Tous les autres seront bloqués.</li>
</ul>
</li>
<li class="nx-my-2">Parmi les scripts CLI, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-acls.sh</code> permet de visualiser et configurer les ACLs.</li>
<li class="nx-my-2">La bonne pratique c&#x27;est d&#x27;<strong>assigner des utilisateurs distincts</strong> à chaque application (publisher, consumer etc.).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La même chose vaut pour le user utilisé pour l&#x27;inter-broker communication : il vaut mieux lui donner les bons droits plutôt que le mettre en super admin.</li>
</ul>
</li>
<li class="nx-my-2">Kafka donne la possibilité d&#x27;<strong>autoriser ou interdire</strong> pour une règle d&#x27;autorisation donnée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les règles d&#x27;interdiction prennent toujours le pas sur les règles d&#x27;autorisation, quelles que soient les granularités.</li>
<li class="nx-my-2">On peut grâce à ça, par exemple :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Partir du fait que le défaut dans Kafka c&#x27;est que tout est interdit pour tout le monde.</li>
<li class="nx-my-2">Puis mettre une règle qui autorise un droit de lecture sur un topic pour tous les utilisateurs (en utilisant le wildcard “<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">*</code>”).</li>
<li class="nx-my-2">Et enfin mettre des règles interdisant ce droit d&#x27;écriture pour certains utilisateurs particuliers (par exemple un utilisateur <em>guest</em> dont on donne les identifiants à ceux qui veulent essayer).</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Il y a des moyens de filtrer plus ou moins de choses quand on liste des droits avec le script CLI <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-acls.sh</code> :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On a la possibilité de lister tous les droits qui pourraient s&#x27;appliquer au nom qu&#x27;on indique (parce qu&#x27;ils comportent des règles de wildcard ou de préfix etc.), grâce à l&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">--resource-pattern-type=any</code>.</li>
<li class="nx-my-2">Ou alors lister seulement les droits qui portent sur le nom exact qu&#x27;on indique, grâce à l&#x27;option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">--resource-pattern-type=match</code>.</li>
</ul>
</li>
<li class="nx-my-2">Kafka permet de créer des règles d&#x27;autorisation ou d&#x27;interdiction pour les clients basé sur leurs adresses IP.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur déconseille cette fonctionnalité, étant donné la nature mouvante des topologies de client dans le cloud.</li>
<li class="nx-my-2">Il conseille à la limite d&#x27;utiliser le firewall pour faire ce genre de restrictions.</li>
</ul>
</li>
<li class="nx-my-2">Voilà quelques <strong>scénarios d&#x27;autorisation habituels</strong> qu&#x27;on met en place :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>Créer des topics</strong> : l&#x27;opération <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Create</code> qu&#x27;on attribue pour les topics commençant par un préfixe.</li>
<li class="nx-my-2"><strong>Supprimer des topics</strong> : l&#x27;opération <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Delete</code> sur les topics avec le même préfixe.</li>
<li class="nx-my-2"><strong>Publier dans un topic</strong> : l&#x27;opération <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Write</code> ou <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">IdempotentWrite</code> (pour que ça marche avec la publication en mode idempotent), qu&#x27;on attribue pour les topics commençant par un préfixe.</li>
<li class="nx-my-2"><strong>Consommer depuis un topic</strong> :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour un consumer sans groupe, il faut l&#x27;opération <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Read</code> sur le topic. En général on met le topic exact pour éviter d&#x27;augmenter l&#x27;exposition des données.</li>
<li class="nx-my-2">Si le consumer fait partie d&#x27;un groupe, alors il faudra aussi l&#x27;opération <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">Read</code> sur le groupe.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">17 - Quotas<a href="#17---quotas" id="17---quotas" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les quotas servent à :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Empêcher les <strong>attaques DOS</strong> en faisant du throttling.</li>
<li class="nx-my-2">Aider à <strong>planifier la capacité</strong> de la machine pour assurer une bonne qualité de service.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En particulier quand on commence à avoir suffisamment de clients Kafka pour que les quelques brokers initialement nécessaires commencent à manquer de ressources.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les quotas s&#x27;appliquent aux <strong>utilisateurs</strong> au niveau de <strong>chaque broker</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ca veut dire qu&#x27;il faut prendre en compte le nombre de brokers, et potentiellement revoir les quotas quand on ajoute des brokers.</li>
</ul>
</li>
<li class="nx-my-2">Il existe deux types de quotas :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><strong>1 - Network bandwidth quotas</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Vérifie que les producers et consumers ne dépassent pas une certaine quantité de données transférées (en bytes / seconde).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ca permet d&#x27;englober de nombreux aspects : bande passante réseau, ressources I/O, ressources mémoire à cause du buffering, ressources CPU dans le cas du chiffrement TLS.</li>
</ul>
</li>
<li class="nx-my-2">Le broker calcule l&#x27;utilisation de la bande passante de chaque client par fenêtre glissante.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Quand il y a un dépassement, le broker va <strong>introduire artificiellement un délai</strong> avant de répondre. Le client ne saura donc pas s&#x27;il a subi une restriction ou si c&#x27;est juste des lenteurs réseau.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><strong>2 - Request rate quotas</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Vérifie que les producers et consumers n&#x27;utilisent pas plus d&#x27;un certain pourcentage de CPU d&#x27;un thread I/O.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">50% correspond à la moitié de l&#x27;utilisation du thread I/O, 200% correspond à l&#x27;utilisation pleine de 2 threads.</li>
</ul>
</li>
<li class="nx-my-2">Le <em>network bandwidth quota</em> couvre déjà une grande partie des cas. <em>Request rate quotas</em> vient le compléter dans les cas où <strong>un client a fait un mauvais réglage</strong> qui l&#x27;amène à faire un très grand nombre de requêtes vers le serveur, sans qu&#x27;il n&#x27;y ait forcément beaucoup de données dans ces requêtes.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ca peut être par exemple si un consumer a configuré une valeur de <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">fetch.max.wait.ms</code> très basse, le poussant à faire des requêtes très régulières pour demander plus de records.</li>
<li class="nx-my-2">Comme autre cas de mauvaise configuration, ça peut aussi être de nombreuses requêtes qui aboutissent à “unauthorized”, ou encore une configuration différente de la compression entre client et serveur, aboutissant à une sur-utilisation du CPU inutile.</li>
</ul>
</li>
<li class="nx-my-2">Ce mode de quota fonctionne aussi par fenêtre glissante, et ajoute aussi des pénalités d&#x27;attente silencieuses en cas de dépassement.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les quotas sont <strong>attribués aux usernames et aux client IDs</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les <em>usernames</em> sont ceux qui sont utilisés et vérifiés par Kafka par les mécanismes d&#x27;authentification (champ CN du certificat en cas d&#x27;authentification par mutual TLS, et champ username en cas d&#x27;authentification SASL) et d&#x27;autorisation.</li>
<li class="nx-my-2">Les <em>client IDs</em> sont les identifiants qu&#x27;un client <strong>déclare librement</strong> au moment de se connecter au serveur, avec le champ <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">client.id</code>.</li>
<li class="nx-my-2">On utilise souvent une combinaison des deux : le username pour l&#x27;authentification, et le client ID pour distinguer plusieurs machines appartenant à la même personne ou au même groupe de personnes.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;attribution se fait via <strong>configuration dynamique</strong>, via le script CLI <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">kafka-configs.sh</code> ou un autre client admin.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il est possible de spécifier des quotas pour un couple username / client ID, sachant que chaque membre du couple de valeurs peut avoir soit une valeur, soit la valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">&amp;lt;default&gt;</code>, soit ne pas avoir de valeur.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le fait de savoir quelle règle de quota va s&#x27;appliquer se fait par matching parmi les règles existantes, avec une <strong>priorité aux règles les plus précises</strong>.</li>
</ul>
</li>
<li class="nx-my-2">En fonction de la règle de quota qui est retenue pour chaque consumer, <strong>si deux consumers partagent la même règle, ils partageront aussi la valeur du quota</strong>.</li>
<li class="nx-my-2">D&#x27;un point de vue sécurité, l&#x27;auteur conseille de spécifier d&#x27;abord des valeurs par défaut qui sont très basses (en commençant par le couple username / client ID : <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">&amp;lt;default&gt;</code> / <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">&amp;lt;default&gt;</code>), et ensuite de les écraser par des règles plus spécifiques ayant des quotas plus larges.</li>
</ul>
</li>
<li class="nx-my-2">La propriété <strong>buffer.memory</strong> (par défaut 32 Mo) côté client permet de le bloquer quand le buffer dépasse cette taille, ce qui peut permettre d&#x27;éviter le throttling côté serveur.</li>
<li class="nx-my-2">Le fait que <strong>le client ne sache pas s&#x27;il fait l&#x27;objet de pénalités d&#x27;attente</strong> ou s&#x27;il y a simplement de la congestion sur le réseau, peut poser problème dans certains cas.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il peut bombarder de requêtes et finir par subir une attente si longue qu&#x27;elle dépasserait le delivery timeout. Il pourrait alors avoir tendance à réessayer plusieurs fois, menant à une forme de <em>congestive collapse</em>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">En général on peut résoudre ce problème en diminuant la propriété <strong>buffer.memory</strong> (par défaut 32 Mo) côté client pour obliger le client à attendre avant de publier plus que ce qu&#x27;il a en buffer.</li>
</ul>
</li>
<li class="nx-my-2">Parfois on se trouve dans un cas où le client veut publier beaucoup de messages, et parmi eux la plupart des messages sans urgence particulière, et certains messages urgents dont il ne veut pas qu&#x27;ils fassent l&#x27;objet de ralentissement.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans ce cas, il est obligé d&#x27;essayer de deviner (par des moyens probabilistes) s&#x27;il fait l&#x27;objet de pénalités liées au quotas ou pas, pour éviter d&#x27;envoyer les autres messages le temps d&#x27;envoyer les messages urgents.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - Il peut noter le nombre records envoyés mais pas encore acknowledgés par le broker : normalement ce chiffre devrait augmenter en cas de throttling, et diminuer pour atteindre presque 0 dans le cas contraire.</li>
<li class="nx-my-2">2 - Il peut noter le timestamp du dernier record, et le comparer au temps actuel : s&#x27;il y a une différence importante, il est possible qu&#x27;il y ait eu du throttling.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">La méthode de <strong>fenêtres glissantes</strong> qui calcule s&#x27;il faut appliquer des pénalités d&#x27;attente est configurable.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le calcul se fait sur N samples d&#x27;une durée de S secondes, qui se renouvellent sample par sample.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">N est configurable par <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">quota.window.num</code> (par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">11</code> samples).</li>
<li class="nx-my-2">S est configurable par <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">quota.window.size.seconds</code> (par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">1</code> seconde).</li>
</ul>
</li>
<li class="nx-my-2">Une fois qu&#x27;un client a dépassé le quota dans la fenêtre de samples, il pourra à chaque sample de temps publier une quantité minimale, jusqu&#x27;à ce que sa consommation totale sur la fenêtre redescende en dessous de sa limite de quota.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ça implique qu&#x27;un client qui publie à fond produise des pics tous les N samples, suivis de très faibles quantités publiées.</li>
</ul>
</li>
<li class="nx-my-2">A propos de la stratégie de tuning de ces règles :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Plus on va <strong>augmenter <em>quota.window.num</em></strong>, et plus <strong>le pic ponctuel pourra être élevé</strong> avant de subir une pénalité.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur conseille d&#x27;éventuellement modifier ce paramètre en conséquence.</li>
</ul>
</li>
<li class="nx-my-2">Plus on va <strong>augmenter <em>quota.window.size.seconds</em></strong>, et plus <strong>le temps d&#x27;attente de pénalité sera long</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">L&#x27;auteur conseille de ne pas y toucher et de le laisser au minimum, c&#x27;est à dire 1 seconde.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Attention cependant, ce comportement non uniforme qui provoque des pics n&#x27;est pas documenté, et pourrait être modifié sans avoir besoin d&#x27;un process long.</li>
</ul>
</li>
</ul>
<h2 class="nx-font-semibold nx-tracking-tight nx-text-slate-900 dark:nx-text-slate-100 nx-mt-10 nx-border-b nx-pb-1 nx-text-3xl nx-border-neutral-200/70 contrast-more:nx-border-neutral-400 dark:nx-border-primary-100/10 contrast-more:dark:nx-border-neutral-400">18 - Transactions<a href="#18---transactions" id="18---transactions" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les transactions permettent de réaliser des <strong>exactly-once deliveries à travers une pipeline de plusieurs jobs</strong> (qu&#x27;on appelle <em>stages</em>) chaînés via des topics Kafka successifs.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ils y arrivent parce qu&#x27;ils permettent de <strong>réaliser l&#x27;idempotence à travers plusieurs stages</strong>, et qu&#x27;en combinant ça avec l&#x27;<em>at-least-one delivery</em>, on obtient l&#x27;<em>exactly-one delivery</em>.</li>
</ul>
</li>
<li class="nx-my-2">La <strong>problématique</strong> est la suivante :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On part d&#x27;un cas où on a un <em>stage</em> qui a besoin de consommer un topic Kafka, et pour chaque record consommé, publier un record dans un autre topic Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On ne s&#x27;intéresse pas ici à d&#x27;autres side-effects comme l&#x27;écriture en DB pour laquelle les transactions Kafka ne peuvent rien, mais bien seulement aux messages Kafka publiés et consommés.</li>
</ul>
</li>
<li class="nx-my-2">Les problèmes suivants peuvent se produire :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Des <strong>erreurs réseau et des crashs du serveur</strong>, pour lesquelles on n&#x27;a pas besoin des transactions.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le consumer peut les gérer grâce au mécanisme de retries tant qu&#x27;il n&#x27;a pas fait le commit d&#x27;offset.</li>
<li class="nx-my-2">Le producer peut les gérer grâce au mécanisme de retries tant qu&#x27;il n&#x27;a pas reçu d&#x27;acknowledgement, et au mécanisme d&#x27;idempotence qui garantit l&#x27;ordre et la déduplication.</li>
</ul>
</li>
<li class="nx-my-2">Pour les <strong>crashs du process client</strong> on a un point faible : le cas où le client a déjà commencé à exécuter la callback du record, et est arrivé jusqu&#x27;à publier le record sortant, mais <strong>n&#x27;a pas encore fait le commit de son offset</strong> en tant que consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">S&#x27;il crash à ce moment-là, la prochaine fois qu&#x27;il se réveille il va traiter le même record entrant, et va publier encore le record qu&#x27;il avait déjà publié.</li>
<li class="nx-my-2">On a donc un risque de publier le message sortant plusieurs fois, sans que la publication avec l&#x27;option d&#x27;idempotence ne puisse rien y faire, puisqu&#x27;il ne s&#x27;agit pas de retries d&#x27;un même message.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le même problème peut se généraliser avec la publication de plusieurs messages qui doivent tous n&#x27;être publiés qu&#x27;une fois par le stage.</li>
</ul>
</li>
<li class="nx-my-2">Alors que Kafka permet de base une bonne <em>durability</em> (notamment grâce à la réplication des données dans chaque broker), avec le mécanisme de transactions il se voit doté d&#x27;autres caractéristiques d&#x27;<strong>ACID</strong> :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Atomicity : l&#x27;ensemble des messages publiés dans une même transaction sont soit tous validés, soit tous non validés, y compris dans des topics et partitions différents.</li>
<li class="nx-my-2">Consistency : on ne se retrouve pas dans un demi-état, soit tous les records sont validés, soit aucun.</li>
<li class="nx-my-2">Isolation : les transactions faites en parallèle ont le même résultat que si elles étaient faites les unes après les autres.</li>
</ul>
</li>
<li class="nx-my-2">D&#x27;un point de vue performance, on n&#x27;a que 3 à 5% de diminution du throughput quand on utilise les transactions.</li>
<li class="nx-my-2">Pour ce qui est du <strong>fonctionnement détaillé</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Les <strong>transaction coordinators</strong> tournent sur les brokers.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ils ont pour rôle :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">1 - d&#x27;assigner un ID à chaque producer (Producer ID, ou PID) qui en fait la demande.</li>
<li class="nx-my-2">2 - gérer le statut des transactions dans un topic caché de Kafka (dont le nom est <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__transaction_state</code>).</li>
</ul>
</li>
<li class="nx-my-2">Pour que le système de transactions fonctionne, il faut que <strong>le PID du producer reste le même entre deux records consommés</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Et pour ça, il faut que le producer du stage suivant déclare le même <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">transactional.id</code> que le précédent.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce qui a pour effet que le transaction coordinator va assigner le même PID, tant que le délai <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">transactional.id.expiration</code> (par défaut 1 semaine) n&#x27;est pas dépassé.</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;association [ transactional ID, PID ] contient une propriété <strong>epoch</strong> qui indique la date de la dernière mise à jour de cette association.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ce mécanisme permet de bloquer les process client zombies, c&#x27;est-à-dire qui ont été éjectés, mais qui continuent de penser que c&#x27;est à eux de publier : si leur epoch est plus ancien, ils ne pourront pas publier.</li>
</ul>
</li>
<li class="nx-my-2">Garder le même PID permet aussi au producteur successeur de terminer les transactions non terminées du producer qui vient de crash ou timeout.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">L&#x27;essentiel de l&#x27;aspect transactionnel se passe côté <strong>API du producer</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le client producer Java a ces méthodes :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">initTransactions()</code> permet d&#x27;initialiser le système de transactions pour un producer donné.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On ne l&#x27;appelle qu&#x27;une fois, et ça assigne un PID et un epoch pour l&#x27;association [ transactional ID, PID ].</li>
<li class="nx-my-2">Ça va aussi attendre que les transactions précédentes associées à ce transactional ID soient terminées (soit COMMITED, soit ABORTED).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas où le consumer précédent n&#x27;a pas eu le temps de dire s&#x27;il voulait commit ou abort, par défaut le broker va déclarer la transaction ABORTED.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">beginTransaction()</code> permet de commencer la transaction.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">sendOffsetsToTransaction()</code> envoie les offsets du consumer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le consumer va donc faire son commit à travers l&#x27;API du producer, et non pas avec sa méthode commit habituelle.</li>
<li class="nx-my-2">Il faut bien sûr que l&#x27;auto-commit soit désactivé pour le consumer.</li>
</ul>
</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">commitTransaction()</code> permet de valider la transaction.</li>
<li class="nx-my-2"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">abortTransaction()</code> permet de l&#x27;annuler.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Le <strong>choix du transactional ID</strong> est un des sujets majeurs de confusion autour des transactions Kafka.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Parmi les possibilités naïves qu&#x27;on pourrait imaginer :<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Si on lui attribue une même valeur parmi l&#x27;ensemble des producer process d&#x27;un même stage, seul l&#x27;instance de producer la plus récente pourra prendre la main, en transformant les producers qui sont issus de la lecture de toutes les autres partitions, en zombies.</li>
<li class="nx-my-2">Si on lui attribue une valeur complètement aléatoire et unique du type UUID, alors aucun producer ne sera transformé en zombie, pas même ceux qui auront été éjectés à cause d&#x27;un timeout.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Ces process à qui on aurait enlevé la responsabilité de leurs partitions, et qui seraient encore en train d&#x27;attendre qu&#x27;une transaction se termine, pourraient encore bloquer le fait que de nouveaux messages apparraissent dans leurs anciennes partitions pendant <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">transactional.id.expiration.ms</code> (par défaut 1 heure).</li>
<li class="nx-my-2">Dans le cas où ces process auraient encore des messages dans leur buffer, ils pourraient aussi continuer à exécuter leurs callbacks.</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">La bonne solution est d&#x27;assigner un transactional ID composé de la <strong>concaténation entre l&#x27;input topic et l&#x27;index de la partition de ce topic</strong> qu&#x27;on est en train de consommer.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le résultat c&#x27;est potentiellement un grand nombre de producers créés, avec chacun son transactional ID composé du topic et de l&#x27;index de la partition.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour éviter d&#x27;en avoir trop, l&#x27;approche privilégiée est de ne créer que les producers pour les partitions assignées à un consumer donné, et de les supprimer si les partitions sont rebalancées et enlevées.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Côté <strong>consumers</strong>, la notion de transaction se matérialise dans le choix de ce qui sera lu.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Quand le producer publie des messages dans des topics dans le cadre d&#x27;une transaction, il va les <strong>publier directement et de manière irrévocable</strong>, mais ils seront entourés de <strong>markers</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Il y a un marker pour indiquer le début de la transaction dans la partition, et un autre pour indiquer la fin de transaction réussie (COMMITTED) ou échouée (ABORTED).</li>
</ul>
</li>
<li class="nx-my-2">Le consumer dispose d&#x27;une option <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">isolation.level</code> (par défaut <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_uncommited</code>).<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">La valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_uncommited</code> permet de lire tous les records de la partition, ceux qui ne font pas partie d&#x27;une transaction comme ceux qui en font partie, que la transaction soit validée, annulée, ou toujours en cours.</li>
<li class="nx-my-2">La valeur <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_commited</code> permet de ne lire que les records qui ne font pas partie d&#x27;une transaction, ou ceux qui sont dans une transaction validée.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Pour un consumer qui a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">read_commited</code> activé, l&#x27;End Offset est remplacé par la notion de <strong>LSO (Last Stable Offset)</strong>, qui pointe vers le dernier record qui ne fait pas partie d&#x27;une transaction non terminée.</li>
<li class="nx-my-2">Tant que la transaction est en cours, le consumer ne pourra pas lire plus loin.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="nx-my-2">Les transactions ont un certain nombre de <strong>limitations</strong>.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Le système de transaction de Kafka n&#x27;est pas compatible avec d&#x27;autres systèmes de transaction comme XA ou JTA.</li>
<li class="nx-my-2">Une transaction est limitée à un même producer (même transactional ID, même PID).</li>
<li class="nx-my-2">La transaction peut être <strong>lue de manière partielle</strong> par des consumers sans qu&#x27;ils s&#x27;en rendent compte : il suffit que le consumer n&#x27;ait à sa charge que certaines partitions où la transaction a publié des messages, mais pas les autres.</li>
<li class="nx-my-2">La exactly-once delivery ne s‘applique pas aux side effects en dehors de Kafka : par exemple on peut jouer une callback plusieurs fois, et ajouter plusieurs entrées en DB, même si côté Kafka les messages sont bien publiés exactly-once.</li>
</ul>
</li>
<li class="nx-my-2"><strong>Faut-il utiliser les transactions ?</strong>
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">On peut se poser la question de la complexité additionnelle par rapport à ce que ça apporte : une déduplication des messages à travers les stages.<!-- -->
<ul class="nx-mt-6 nx-list-disc first:nx-mt-0 ltr:nx-ml-6 rtl:nx-mr-6">
<li class="nx-my-2">Dans le cas où la consommation de nos messages n&#x27;a que des side-effects idempotents, alors avoir des messages en double dans Kafka peut ne pas être problématique.</li>
<li class="nx-my-2">D&#x27;un autre côté, la complexité en question peut être abstraite dans une couche adapter.</li>
</ul>
</li>
</ul>
</li>
</ul><div class="nx-mt-16"></div><div class="nx-mb-8 nx-flex nx-items-center nx-border-t nx-pt-8 dark:nx-border-neutral-800 contrast-more:nx-border-neutral-400 dark:contrast-more:nx-border-neutral-400 print:nx-hidden"><a title="Designing Data-Intensive Applications" class="nx-flex nx-max-w-[50%] nx-items-center nx-gap-1 nx-py-4 nx-text-base nx-font-medium nx-text-gray-600 nx-transition-colors [word-break:break-word] hover:nx-text-primary-600 dark:nx-text-gray-300 md:nx-text-lg ltr:nx-pr-4 rtl:nx-pl-4" href="/reading-notes/books/designing-data-intensive-applications/"><svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="nx-inline nx-h-5 nx-shrink-0 ltr:nx-rotate-180"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>Designing Data-Intensive Applications</a><a title="Effective TypeScript" class="nx-flex nx-max-w-[50%] nx-items-center nx-gap-1 nx-py-4 nx-text-base nx-font-medium nx-text-gray-600 nx-transition-colors [word-break:break-word] hover:nx-text-primary-600 dark:nx-text-gray-300 md:nx-text-lg ltr:nx-ml-auto ltr:nx-pl-4 ltr:nx-text-right rtl:nx-mr-auto rtl:nx-pr-4 rtl:nx-text-left" href="/reading-notes/books/effective-typescript/">Effective TypeScript<svg fill="none" viewBox="0 0 24 24" stroke="currentColor" class="nx-inline nx-h-5 nx-shrink-0 rtl:nx-rotate-180"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></a></div></main></article></div><footer class="nx-bg-gray-100 nx-pb-[env(safe-area-inset-bottom)] dark:nx-bg-neutral-900 print:nx-bg-transparent"><div class="nx-mx-auto nx-flex nx-max-w-[90rem] nx-gap-2 nx-py-2 nx-px-4 nx-hidden"><button title="Change theme" class="nx-h-7 nx-rounded-md nx-px-2 nx-text-left nx-text-xs nx-font-medium nx-text-gray-600 nx-transition-colors dark:nx-text-gray-400 hover:nx-bg-gray-100 hover:nx-text-gray-900 dark:hover:nx-bg-primary-100/5 dark:hover:nx-text-gray-50" id="headlessui-listbox-button-:Rkt6:" type="button" aria-haspopup="listbox" aria-expanded="false" data-headlessui-state=""><div class="nx-flex nx-items-center nx-gap-2 nx-capitalize"><svg fill="none" viewBox="3 3 18 18" width="12" height="12" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" fill="currentColor" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg><span class="">Light</span></div></button></div><hr class="dark:nx-border-neutral-800"/><div class="nx-mx-auto nx-flex nx-max-w-[90rem] nx-justify-center nx-py-12 nx-text-gray-600 dark:nx-text-gray-400 md:nx-justify-start nx-pl-[max(env(safe-area-inset-left),1.5rem)] nx-pr-[max(env(safe-area-inset-right),1.5rem)]">Made by Roman Mkrtchian</div></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{}},"page":"/books/effective-kafka","query":{},"buildId":"vxJYrrk_6viBDsRgUryN3","assetPrefix":"/reading-notes","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>